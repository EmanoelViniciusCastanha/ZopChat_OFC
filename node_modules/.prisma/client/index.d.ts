
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Messages
 * 
 */
export type Messages = $Result.DefaultSelection<Prisma.$MessagesPayload>
/**
 * Model grupo
 * 
 */
export type grupo = $Result.DefaultSelection<Prisma.$grupoPayload>
/**
 * Model grupos_pessoas
 * 
 */
export type grupos_pessoas = $Result.DefaultSelection<Prisma.$grupos_pessoasPayload>
/**
 * Model mensagem_grupo
 * 
 */
export type mensagem_grupo = $Result.DefaultSelection<Prisma.$mensagem_grupoPayload>
/**
 * Model mensagem_privada
 * 
 */
export type mensagem_privada = $Result.DefaultSelection<Prisma.$mensagem_privadaPayload>
/**
 * Model pessoa
 * 
 */
export type pessoa = $Result.DefaultSelection<Prisma.$pessoaPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Messages
 * const messages = await prisma.messages.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Messages
   * const messages = await prisma.messages.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.messages`: Exposes CRUD operations for the **Messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.messages.findMany()
    * ```
    */
  get messages(): Prisma.MessagesDelegate<ExtArgs>;

  /**
   * `prisma.grupo`: Exposes CRUD operations for the **grupo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grupos
    * const grupos = await prisma.grupo.findMany()
    * ```
    */
  get grupo(): Prisma.grupoDelegate<ExtArgs>;

  /**
   * `prisma.grupos_pessoas`: Exposes CRUD operations for the **grupos_pessoas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grupos_pessoas
    * const grupos_pessoas = await prisma.grupos_pessoas.findMany()
    * ```
    */
  get grupos_pessoas(): Prisma.grupos_pessoasDelegate<ExtArgs>;

  /**
   * `prisma.mensagem_grupo`: Exposes CRUD operations for the **mensagem_grupo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mensagem_grupos
    * const mensagem_grupos = await prisma.mensagem_grupo.findMany()
    * ```
    */
  get mensagem_grupo(): Prisma.mensagem_grupoDelegate<ExtArgs>;

  /**
   * `prisma.mensagem_privada`: Exposes CRUD operations for the **mensagem_privada** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mensagem_privadas
    * const mensagem_privadas = await prisma.mensagem_privada.findMany()
    * ```
    */
  get mensagem_privada(): Prisma.mensagem_privadaDelegate<ExtArgs>;

  /**
   * `prisma.pessoa`: Exposes CRUD operations for the **pessoa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pessoas
    * const pessoas = await prisma.pessoa.findMany()
    * ```
    */
  get pessoa(): Prisma.pessoaDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.19.1
   * Query Engine version: 69d742ee20b815d88e17e54db4a2a7a3b30324e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Messages: 'Messages',
    grupo: 'grupo',
    grupos_pessoas: 'grupos_pessoas',
    mensagem_grupo: 'mensagem_grupo',
    mensagem_privada: 'mensagem_privada',
    pessoa: 'pessoa'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "messages" | "grupo" | "grupos_pessoas" | "mensagem_grupo" | "mensagem_privada" | "pessoa"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Messages: {
        payload: Prisma.$MessagesPayload<ExtArgs>
        fields: Prisma.MessagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          findFirst: {
            args: Prisma.MessagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          findMany: {
            args: Prisma.MessagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>[]
          }
          create: {
            args: Prisma.MessagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          createMany: {
            args: Prisma.MessagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>[]
          }
          delete: {
            args: Prisma.MessagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          update: {
            args: Prisma.MessagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          deleteMany: {
            args: Prisma.MessagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          aggregate: {
            args: Prisma.MessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessages>
          }
          groupBy: {
            args: Prisma.MessagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessagesCountArgs<ExtArgs>
            result: $Utils.Optional<MessagesCountAggregateOutputType> | number
          }
        }
      }
      grupo: {
        payload: Prisma.$grupoPayload<ExtArgs>
        fields: Prisma.grupoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.grupoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.grupoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>
          }
          findFirst: {
            args: Prisma.grupoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.grupoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>
          }
          findMany: {
            args: Prisma.grupoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>[]
          }
          create: {
            args: Prisma.grupoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>
          }
          createMany: {
            args: Prisma.grupoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.grupoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>[]
          }
          delete: {
            args: Prisma.grupoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>
          }
          update: {
            args: Prisma.grupoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>
          }
          deleteMany: {
            args: Prisma.grupoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.grupoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.grupoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>
          }
          aggregate: {
            args: Prisma.GrupoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrupo>
          }
          groupBy: {
            args: Prisma.grupoGroupByArgs<ExtArgs>
            result: $Utils.Optional<GrupoGroupByOutputType>[]
          }
          count: {
            args: Prisma.grupoCountArgs<ExtArgs>
            result: $Utils.Optional<GrupoCountAggregateOutputType> | number
          }
        }
      }
      grupos_pessoas: {
        payload: Prisma.$grupos_pessoasPayload<ExtArgs>
        fields: Prisma.grupos_pessoasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.grupos_pessoasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupos_pessoasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.grupos_pessoasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupos_pessoasPayload>
          }
          findFirst: {
            args: Prisma.grupos_pessoasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupos_pessoasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.grupos_pessoasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupos_pessoasPayload>
          }
          findMany: {
            args: Prisma.grupos_pessoasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupos_pessoasPayload>[]
          }
          create: {
            args: Prisma.grupos_pessoasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupos_pessoasPayload>
          }
          createMany: {
            args: Prisma.grupos_pessoasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.grupos_pessoasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupos_pessoasPayload>[]
          }
          delete: {
            args: Prisma.grupos_pessoasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupos_pessoasPayload>
          }
          update: {
            args: Prisma.grupos_pessoasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupos_pessoasPayload>
          }
          deleteMany: {
            args: Prisma.grupos_pessoasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.grupos_pessoasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.grupos_pessoasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grupos_pessoasPayload>
          }
          aggregate: {
            args: Prisma.Grupos_pessoasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrupos_pessoas>
          }
          groupBy: {
            args: Prisma.grupos_pessoasGroupByArgs<ExtArgs>
            result: $Utils.Optional<Grupos_pessoasGroupByOutputType>[]
          }
          count: {
            args: Prisma.grupos_pessoasCountArgs<ExtArgs>
            result: $Utils.Optional<Grupos_pessoasCountAggregateOutputType> | number
          }
        }
      }
      mensagem_grupo: {
        payload: Prisma.$mensagem_grupoPayload<ExtArgs>
        fields: Prisma.mensagem_grupoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mensagem_grupoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_grupoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mensagem_grupoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_grupoPayload>
          }
          findFirst: {
            args: Prisma.mensagem_grupoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_grupoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mensagem_grupoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_grupoPayload>
          }
          findMany: {
            args: Prisma.mensagem_grupoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_grupoPayload>[]
          }
          create: {
            args: Prisma.mensagem_grupoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_grupoPayload>
          }
          createMany: {
            args: Prisma.mensagem_grupoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mensagem_grupoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_grupoPayload>[]
          }
          delete: {
            args: Prisma.mensagem_grupoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_grupoPayload>
          }
          update: {
            args: Prisma.mensagem_grupoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_grupoPayload>
          }
          deleteMany: {
            args: Prisma.mensagem_grupoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mensagem_grupoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.mensagem_grupoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_grupoPayload>
          }
          aggregate: {
            args: Prisma.Mensagem_grupoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMensagem_grupo>
          }
          groupBy: {
            args: Prisma.mensagem_grupoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mensagem_grupoGroupByOutputType>[]
          }
          count: {
            args: Prisma.mensagem_grupoCountArgs<ExtArgs>
            result: $Utils.Optional<Mensagem_grupoCountAggregateOutputType> | number
          }
        }
      }
      mensagem_privada: {
        payload: Prisma.$mensagem_privadaPayload<ExtArgs>
        fields: Prisma.mensagem_privadaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mensagem_privadaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_privadaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mensagem_privadaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_privadaPayload>
          }
          findFirst: {
            args: Prisma.mensagem_privadaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_privadaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mensagem_privadaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_privadaPayload>
          }
          findMany: {
            args: Prisma.mensagem_privadaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_privadaPayload>[]
          }
          create: {
            args: Prisma.mensagem_privadaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_privadaPayload>
          }
          createMany: {
            args: Prisma.mensagem_privadaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mensagem_privadaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_privadaPayload>[]
          }
          delete: {
            args: Prisma.mensagem_privadaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_privadaPayload>
          }
          update: {
            args: Prisma.mensagem_privadaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_privadaPayload>
          }
          deleteMany: {
            args: Prisma.mensagem_privadaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mensagem_privadaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.mensagem_privadaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mensagem_privadaPayload>
          }
          aggregate: {
            args: Prisma.Mensagem_privadaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMensagem_privada>
          }
          groupBy: {
            args: Prisma.mensagem_privadaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mensagem_privadaGroupByOutputType>[]
          }
          count: {
            args: Prisma.mensagem_privadaCountArgs<ExtArgs>
            result: $Utils.Optional<Mensagem_privadaCountAggregateOutputType> | number
          }
        }
      }
      pessoa: {
        payload: Prisma.$pessoaPayload<ExtArgs>
        fields: Prisma.pessoaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pessoaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pessoaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          findFirst: {
            args: Prisma.pessoaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pessoaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          findMany: {
            args: Prisma.pessoaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>[]
          }
          create: {
            args: Prisma.pessoaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          createMany: {
            args: Prisma.pessoaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pessoaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>[]
          }
          delete: {
            args: Prisma.pessoaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          update: {
            args: Prisma.pessoaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          deleteMany: {
            args: Prisma.pessoaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pessoaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pessoaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          aggregate: {
            args: Prisma.PessoaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePessoa>
          }
          groupBy: {
            args: Prisma.pessoaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PessoaGroupByOutputType>[]
          }
          count: {
            args: Prisma.pessoaCountArgs<ExtArgs>
            result: $Utils.Optional<PessoaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MessagesCountOutputType
   */

  export type MessagesCountOutputType = {
    mensagem_grupo: number
    mensagem_privada: number
  }

  export type MessagesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mensagem_grupo?: boolean | MessagesCountOutputTypeCountMensagem_grupoArgs
    mensagem_privada?: boolean | MessagesCountOutputTypeCountMensagem_privadaArgs
  }

  // Custom InputTypes
  /**
   * MessagesCountOutputType without action
   */
  export type MessagesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesCountOutputType
     */
    select?: MessagesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessagesCountOutputType without action
   */
  export type MessagesCountOutputTypeCountMensagem_grupoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mensagem_grupoWhereInput
  }

  /**
   * MessagesCountOutputType without action
   */
  export type MessagesCountOutputTypeCountMensagem_privadaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mensagem_privadaWhereInput
  }


  /**
   * Count Type GrupoCountOutputType
   */

  export type GrupoCountOutputType = {
    Messages: number
    grupos_pessoas: number
  }

  export type GrupoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Messages?: boolean | GrupoCountOutputTypeCountMessagesArgs
    grupos_pessoas?: boolean | GrupoCountOutputTypeCountGrupos_pessoasArgs
  }

  // Custom InputTypes
  /**
   * GrupoCountOutputType without action
   */
  export type GrupoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrupoCountOutputType
     */
    select?: GrupoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GrupoCountOutputType without action
   */
  export type GrupoCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesWhereInput
  }

  /**
   * GrupoCountOutputType without action
   */
  export type GrupoCountOutputTypeCountGrupos_pessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grupos_pessoasWhereInput
  }


  /**
   * Count Type PessoaCountOutputType
   */

  export type PessoaCountOutputType = {
    Messages: number
    grupos_pessoas: number
    mensagem_grupo: number
    mensagem_privada: number
  }

  export type PessoaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Messages?: boolean | PessoaCountOutputTypeCountMessagesArgs
    grupos_pessoas?: boolean | PessoaCountOutputTypeCountGrupos_pessoasArgs
    mensagem_grupo?: boolean | PessoaCountOutputTypeCountMensagem_grupoArgs
    mensagem_privada?: boolean | PessoaCountOutputTypeCountMensagem_privadaArgs
  }

  // Custom InputTypes
  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaCountOutputType
     */
    select?: PessoaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountGrupos_pessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grupos_pessoasWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountMensagem_grupoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mensagem_grupoWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountMensagem_privadaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mensagem_privadaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Messages
   */

  export type AggregateMessages = {
    _count: MessagesCountAggregateOutputType | null
    _avg: MessagesAvgAggregateOutputType | null
    _sum: MessagesSumAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  export type MessagesAvgAggregateOutputType = {
    id: number | null
    id_receptor: number | null
    id_pessoa: number | null
    id_grupo: number | null
  }

  export type MessagesSumAggregateOutputType = {
    id: bigint | null
    id_receptor: bigint | null
    id_pessoa: bigint | null
    id_grupo: bigint | null
  }

  export type MessagesMinAggregateOutputType = {
    id: bigint | null
    id_receptor: bigint | null
    data_cadastro: Date | null
    id_pessoa: bigint | null
    id_grupo: bigint | null
  }

  export type MessagesMaxAggregateOutputType = {
    id: bigint | null
    id_receptor: bigint | null
    data_cadastro: Date | null
    id_pessoa: bigint | null
    id_grupo: bigint | null
  }

  export type MessagesCountAggregateOutputType = {
    id: number
    id_receptor: number
    data_cadastro: number
    id_pessoa: number
    id_grupo: number
    _all: number
  }


  export type MessagesAvgAggregateInputType = {
    id?: true
    id_receptor?: true
    id_pessoa?: true
    id_grupo?: true
  }

  export type MessagesSumAggregateInputType = {
    id?: true
    id_receptor?: true
    id_pessoa?: true
    id_grupo?: true
  }

  export type MessagesMinAggregateInputType = {
    id?: true
    id_receptor?: true
    data_cadastro?: true
    id_pessoa?: true
    id_grupo?: true
  }

  export type MessagesMaxAggregateInputType = {
    id?: true
    id_receptor?: true
    data_cadastro?: true
    id_pessoa?: true
    id_grupo?: true
  }

  export type MessagesCountAggregateInputType = {
    id?: true
    id_receptor?: true
    data_cadastro?: true
    id_pessoa?: true
    id_grupo?: true
    _all?: true
  }

  export type MessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to aggregate.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessagesMaxAggregateInputType
  }

  export type GetMessagesAggregateType<T extends MessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessages[P]>
      : GetScalarType<T[P], AggregateMessages[P]>
  }




  export type MessagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesWhereInput
    orderBy?: MessagesOrderByWithAggregationInput | MessagesOrderByWithAggregationInput[]
    by: MessagesScalarFieldEnum[] | MessagesScalarFieldEnum
    having?: MessagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessagesCountAggregateInputType | true
    _avg?: MessagesAvgAggregateInputType
    _sum?: MessagesSumAggregateInputType
    _min?: MessagesMinAggregateInputType
    _max?: MessagesMaxAggregateInputType
  }

  export type MessagesGroupByOutputType = {
    id: bigint
    id_receptor: bigint | null
    data_cadastro: Date
    id_pessoa: bigint
    id_grupo: bigint | null
    _count: MessagesCountAggregateOutputType | null
    _avg: MessagesAvgAggregateOutputType | null
    _sum: MessagesSumAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  type GetMessagesGroupByPayload<T extends MessagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessagesGroupByOutputType[P]>
            : GetScalarType<T[P], MessagesGroupByOutputType[P]>
        }
      >
    >


  export type MessagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_receptor?: boolean
    data_cadastro?: boolean
    id_pessoa?: boolean
    id_grupo?: boolean
    grupo?: boolean | Messages$grupoArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    mensagem_grupo?: boolean | Messages$mensagem_grupoArgs<ExtArgs>
    mensagem_privada?: boolean | Messages$mensagem_privadaArgs<ExtArgs>
    _count?: boolean | MessagesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type MessagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_receptor?: boolean
    data_cadastro?: boolean
    id_pessoa?: boolean
    id_grupo?: boolean
    grupo?: boolean | Messages$grupoArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type MessagesSelectScalar = {
    id?: boolean
    id_receptor?: boolean
    data_cadastro?: boolean
    id_pessoa?: boolean
    id_grupo?: boolean
  }

  export type MessagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grupo?: boolean | Messages$grupoArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    mensagem_grupo?: boolean | Messages$mensagem_grupoArgs<ExtArgs>
    mensagem_privada?: boolean | Messages$mensagem_privadaArgs<ExtArgs>
    _count?: boolean | MessagesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grupo?: boolean | Messages$grupoArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }

  export type $MessagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Messages"
    objects: {
      grupo: Prisma.$grupoPayload<ExtArgs> | null
      pessoa: Prisma.$pessoaPayload<ExtArgs>
      mensagem_grupo: Prisma.$mensagem_grupoPayload<ExtArgs>[]
      mensagem_privada: Prisma.$mensagem_privadaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      id_receptor: bigint | null
      data_cadastro: Date
      id_pessoa: bigint
      id_grupo: bigint | null
    }, ExtArgs["result"]["messages"]>
    composites: {}
  }

  type MessagesGetPayload<S extends boolean | null | undefined | MessagesDefaultArgs> = $Result.GetResult<Prisma.$MessagesPayload, S>

  type MessagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessagesCountAggregateInputType | true
    }

  export interface MessagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Messages'], meta: { name: 'Messages' } }
    /**
     * Find zero or one Messages that matches the filter.
     * @param {MessagesFindUniqueArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessagesFindUniqueArgs>(args: SelectSubset<T, MessagesFindUniqueArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Messages that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessagesFindUniqueOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessagesFindUniqueOrThrowArgs>(args: SelectSubset<T, MessagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindFirstArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessagesFindFirstArgs>(args?: SelectSubset<T, MessagesFindFirstArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindFirstOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessagesFindFirstOrThrowArgs>(args?: SelectSubset<T, MessagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.messages.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messagesWithIdOnly = await prisma.messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessagesFindManyArgs>(args?: SelectSubset<T, MessagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Messages.
     * @param {MessagesCreateArgs} args - Arguments to create a Messages.
     * @example
     * // Create one Messages
     * const Messages = await prisma.messages.create({
     *   data: {
     *     // ... data to create a Messages
     *   }
     * })
     * 
     */
    create<T extends MessagesCreateArgs>(args: SelectSubset<T, MessagesCreateArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessagesCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessagesCreateManyArgs>(args?: SelectSubset<T, MessagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessagesCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessagesCreateManyAndReturnArgs>(args?: SelectSubset<T, MessagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Messages.
     * @param {MessagesDeleteArgs} args - Arguments to delete one Messages.
     * @example
     * // Delete one Messages
     * const Messages = await prisma.messages.delete({
     *   where: {
     *     // ... filter to delete one Messages
     *   }
     * })
     * 
     */
    delete<T extends MessagesDeleteArgs>(args: SelectSubset<T, MessagesDeleteArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Messages.
     * @param {MessagesUpdateArgs} args - Arguments to update one Messages.
     * @example
     * // Update one Messages
     * const messages = await prisma.messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessagesUpdateArgs>(args: SelectSubset<T, MessagesUpdateArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessagesDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessagesDeleteManyArgs>(args?: SelectSubset<T, MessagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessagesUpdateManyArgs>(args: SelectSubset<T, MessagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Messages.
     * @param {MessagesUpsertArgs} args - Arguments to update or create a Messages.
     * @example
     * // Update or create a Messages
     * const messages = await prisma.messages.upsert({
     *   create: {
     *     // ... data to create a Messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messages we want to update
     *   }
     * })
     */
    upsert<T extends MessagesUpsertArgs>(args: SelectSubset<T, MessagesUpsertArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.messages.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessagesCountArgs>(
      args?: Subset<T, MessagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessagesAggregateArgs>(args: Subset<T, MessagesAggregateArgs>): Prisma.PrismaPromise<GetMessagesAggregateType<T>>

    /**
     * Group by Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessagesGroupByArgs['orderBy'] }
        : { orderBy?: MessagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Messages model
   */
  readonly fields: MessagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grupo<T extends Messages$grupoArgs<ExtArgs> = {}>(args?: Subset<T, Messages$grupoArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    pessoa<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mensagem_grupo<T extends Messages$mensagem_grupoArgs<ExtArgs> = {}>(args?: Subset<T, Messages$mensagem_grupoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mensagem_grupoPayload<ExtArgs>, T, "findMany"> | Null>
    mensagem_privada<T extends Messages$mensagem_privadaArgs<ExtArgs> = {}>(args?: Subset<T, Messages$mensagem_privadaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mensagem_privadaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Messages model
   */ 
  interface MessagesFieldRefs {
    readonly id: FieldRef<"Messages", 'BigInt'>
    readonly id_receptor: FieldRef<"Messages", 'BigInt'>
    readonly data_cadastro: FieldRef<"Messages", 'DateTime'>
    readonly id_pessoa: FieldRef<"Messages", 'BigInt'>
    readonly id_grupo: FieldRef<"Messages", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Messages findUnique
   */
  export type MessagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages findUniqueOrThrow
   */
  export type MessagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages findFirst
   */
  export type MessagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages findFirstOrThrow
   */
  export type MessagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages findMany
   */
  export type MessagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages create
   */
  export type MessagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The data needed to create a Messages.
     */
    data: XOR<MessagesCreateInput, MessagesUncheckedCreateInput>
  }

  /**
   * Messages createMany
   */
  export type MessagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessagesCreateManyInput | MessagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Messages createManyAndReturn
   */
  export type MessagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessagesCreateManyInput | MessagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Messages update
   */
  export type MessagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The data needed to update a Messages.
     */
    data: XOR<MessagesUpdateInput, MessagesUncheckedUpdateInput>
    /**
     * Choose, which Messages to update.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages updateMany
   */
  export type MessagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessagesWhereInput
  }

  /**
   * Messages upsert
   */
  export type MessagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The filter to search for the Messages to update in case it exists.
     */
    where: MessagesWhereUniqueInput
    /**
     * In case the Messages found by the `where` argument doesn't exist, create a new Messages with this data.
     */
    create: XOR<MessagesCreateInput, MessagesUncheckedCreateInput>
    /**
     * In case the Messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessagesUpdateInput, MessagesUncheckedUpdateInput>
  }

  /**
   * Messages delete
   */
  export type MessagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter which Messages to delete.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages deleteMany
   */
  export type MessagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessagesWhereInput
  }

  /**
   * Messages.grupo
   */
  export type Messages$grupoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    where?: grupoWhereInput
  }

  /**
   * Messages.mensagem_grupo
   */
  export type Messages$mensagem_grupoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_grupo
     */
    select?: mensagem_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_grupoInclude<ExtArgs> | null
    where?: mensagem_grupoWhereInput
    orderBy?: mensagem_grupoOrderByWithRelationInput | mensagem_grupoOrderByWithRelationInput[]
    cursor?: mensagem_grupoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Mensagem_grupoScalarFieldEnum | Mensagem_grupoScalarFieldEnum[]
  }

  /**
   * Messages.mensagem_privada
   */
  export type Messages$mensagem_privadaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_privada
     */
    select?: mensagem_privadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_privadaInclude<ExtArgs> | null
    where?: mensagem_privadaWhereInput
    orderBy?: mensagem_privadaOrderByWithRelationInput | mensagem_privadaOrderByWithRelationInput[]
    cursor?: mensagem_privadaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Mensagem_privadaScalarFieldEnum | Mensagem_privadaScalarFieldEnum[]
  }

  /**
   * Messages without action
   */
  export type MessagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
  }


  /**
   * Model grupo
   */

  export type AggregateGrupo = {
    _count: GrupoCountAggregateOutputType | null
    _avg: GrupoAvgAggregateOutputType | null
    _sum: GrupoSumAggregateOutputType | null
    _min: GrupoMinAggregateOutputType | null
    _max: GrupoMaxAggregateOutputType | null
  }

  export type GrupoAvgAggregateOutputType = {
    id: number | null
  }

  export type GrupoSumAggregateOutputType = {
    id: bigint | null
  }

  export type GrupoMinAggregateOutputType = {
    id: bigint | null
    nome: string | null
    descricao: string | null
  }

  export type GrupoMaxAggregateOutputType = {
    id: bigint | null
    nome: string | null
    descricao: string | null
  }

  export type GrupoCountAggregateOutputType = {
    id: number
    nome: number
    descricao: number
    _all: number
  }


  export type GrupoAvgAggregateInputType = {
    id?: true
  }

  export type GrupoSumAggregateInputType = {
    id?: true
  }

  export type GrupoMinAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
  }

  export type GrupoMaxAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
  }

  export type GrupoCountAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    _all?: true
  }

  export type GrupoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grupo to aggregate.
     */
    where?: grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos to fetch.
     */
    orderBy?: grupoOrderByWithRelationInput | grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned grupos
    **/
    _count?: true | GrupoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GrupoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GrupoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GrupoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GrupoMaxAggregateInputType
  }

  export type GetGrupoAggregateType<T extends GrupoAggregateArgs> = {
        [P in keyof T & keyof AggregateGrupo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrupo[P]>
      : GetScalarType<T[P], AggregateGrupo[P]>
  }




  export type grupoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grupoWhereInput
    orderBy?: grupoOrderByWithAggregationInput | grupoOrderByWithAggregationInput[]
    by: GrupoScalarFieldEnum[] | GrupoScalarFieldEnum
    having?: grupoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GrupoCountAggregateInputType | true
    _avg?: GrupoAvgAggregateInputType
    _sum?: GrupoSumAggregateInputType
    _min?: GrupoMinAggregateInputType
    _max?: GrupoMaxAggregateInputType
  }

  export type GrupoGroupByOutputType = {
    id: bigint
    nome: string
    descricao: string | null
    _count: GrupoCountAggregateOutputType | null
    _avg: GrupoAvgAggregateOutputType | null
    _sum: GrupoSumAggregateOutputType | null
    _min: GrupoMinAggregateOutputType | null
    _max: GrupoMaxAggregateOutputType | null
  }

  type GetGrupoGroupByPayload<T extends grupoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GrupoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GrupoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GrupoGroupByOutputType[P]>
            : GetScalarType<T[P], GrupoGroupByOutputType[P]>
        }
      >
    >


  export type grupoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    Messages?: boolean | grupo$MessagesArgs<ExtArgs>
    grupos_pessoas?: boolean | grupo$grupos_pessoasArgs<ExtArgs>
    _count?: boolean | GrupoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grupo"]>

  export type grupoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["grupo"]>

  export type grupoSelectScalar = {
    id?: boolean
    nome?: boolean
    descricao?: boolean
  }

  export type grupoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Messages?: boolean | grupo$MessagesArgs<ExtArgs>
    grupos_pessoas?: boolean | grupo$grupos_pessoasArgs<ExtArgs>
    _count?: boolean | GrupoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type grupoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $grupoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "grupo"
    objects: {
      Messages: Prisma.$MessagesPayload<ExtArgs>[]
      grupos_pessoas: Prisma.$grupos_pessoasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      nome: string
      descricao: string | null
    }, ExtArgs["result"]["grupo"]>
    composites: {}
  }

  type grupoGetPayload<S extends boolean | null | undefined | grupoDefaultArgs> = $Result.GetResult<Prisma.$grupoPayload, S>

  type grupoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<grupoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GrupoCountAggregateInputType | true
    }

  export interface grupoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['grupo'], meta: { name: 'grupo' } }
    /**
     * Find zero or one Grupo that matches the filter.
     * @param {grupoFindUniqueArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends grupoFindUniqueArgs>(args: SelectSubset<T, grupoFindUniqueArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Grupo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {grupoFindUniqueOrThrowArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends grupoFindUniqueOrThrowArgs>(args: SelectSubset<T, grupoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Grupo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoFindFirstArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends grupoFindFirstArgs>(args?: SelectSubset<T, grupoFindFirstArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Grupo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoFindFirstOrThrowArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends grupoFindFirstOrThrowArgs>(args?: SelectSubset<T, grupoFindFirstOrThrowArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Grupos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grupos
     * const grupos = await prisma.grupo.findMany()
     * 
     * // Get first 10 Grupos
     * const grupos = await prisma.grupo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const grupoWithIdOnly = await prisma.grupo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends grupoFindManyArgs>(args?: SelectSubset<T, grupoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Grupo.
     * @param {grupoCreateArgs} args - Arguments to create a Grupo.
     * @example
     * // Create one Grupo
     * const Grupo = await prisma.grupo.create({
     *   data: {
     *     // ... data to create a Grupo
     *   }
     * })
     * 
     */
    create<T extends grupoCreateArgs>(args: SelectSubset<T, grupoCreateArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Grupos.
     * @param {grupoCreateManyArgs} args - Arguments to create many Grupos.
     * @example
     * // Create many Grupos
     * const grupo = await prisma.grupo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends grupoCreateManyArgs>(args?: SelectSubset<T, grupoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grupos and returns the data saved in the database.
     * @param {grupoCreateManyAndReturnArgs} args - Arguments to create many Grupos.
     * @example
     * // Create many Grupos
     * const grupo = await prisma.grupo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grupos and only return the `id`
     * const grupoWithIdOnly = await prisma.grupo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends grupoCreateManyAndReturnArgs>(args?: SelectSubset<T, grupoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Grupo.
     * @param {grupoDeleteArgs} args - Arguments to delete one Grupo.
     * @example
     * // Delete one Grupo
     * const Grupo = await prisma.grupo.delete({
     *   where: {
     *     // ... filter to delete one Grupo
     *   }
     * })
     * 
     */
    delete<T extends grupoDeleteArgs>(args: SelectSubset<T, grupoDeleteArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Grupo.
     * @param {grupoUpdateArgs} args - Arguments to update one Grupo.
     * @example
     * // Update one Grupo
     * const grupo = await prisma.grupo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends grupoUpdateArgs>(args: SelectSubset<T, grupoUpdateArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Grupos.
     * @param {grupoDeleteManyArgs} args - Arguments to filter Grupos to delete.
     * @example
     * // Delete a few Grupos
     * const { count } = await prisma.grupo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends grupoDeleteManyArgs>(args?: SelectSubset<T, grupoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grupos
     * const grupo = await prisma.grupo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends grupoUpdateManyArgs>(args: SelectSubset<T, grupoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Grupo.
     * @param {grupoUpsertArgs} args - Arguments to update or create a Grupo.
     * @example
     * // Update or create a Grupo
     * const grupo = await prisma.grupo.upsert({
     *   create: {
     *     // ... data to create a Grupo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grupo we want to update
     *   }
     * })
     */
    upsert<T extends grupoUpsertArgs>(args: SelectSubset<T, grupoUpsertArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoCountArgs} args - Arguments to filter Grupos to count.
     * @example
     * // Count the number of Grupos
     * const count = await prisma.grupo.count({
     *   where: {
     *     // ... the filter for the Grupos we want to count
     *   }
     * })
    **/
    count<T extends grupoCountArgs>(
      args?: Subset<T, grupoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GrupoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GrupoAggregateArgs>(args: Subset<T, GrupoAggregateArgs>): Prisma.PrismaPromise<GetGrupoAggregateType<T>>

    /**
     * Group by Grupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends grupoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: grupoGroupByArgs['orderBy'] }
        : { orderBy?: grupoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, grupoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrupoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the grupo model
   */
  readonly fields: grupoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for grupo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__grupoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Messages<T extends grupo$MessagesArgs<ExtArgs> = {}>(args?: Subset<T, grupo$MessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findMany"> | Null>
    grupos_pessoas<T extends grupo$grupos_pessoasArgs<ExtArgs> = {}>(args?: Subset<T, grupo$grupos_pessoasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grupos_pessoasPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the grupo model
   */ 
  interface grupoFieldRefs {
    readonly id: FieldRef<"grupo", 'BigInt'>
    readonly nome: FieldRef<"grupo", 'String'>
    readonly descricao: FieldRef<"grupo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * grupo findUnique
   */
  export type grupoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * Filter, which grupo to fetch.
     */
    where: grupoWhereUniqueInput
  }

  /**
   * grupo findUniqueOrThrow
   */
  export type grupoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * Filter, which grupo to fetch.
     */
    where: grupoWhereUniqueInput
  }

  /**
   * grupo findFirst
   */
  export type grupoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * Filter, which grupo to fetch.
     */
    where?: grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos to fetch.
     */
    orderBy?: grupoOrderByWithRelationInput | grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grupos.
     */
    cursor?: grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grupos.
     */
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[]
  }

  /**
   * grupo findFirstOrThrow
   */
  export type grupoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * Filter, which grupo to fetch.
     */
    where?: grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos to fetch.
     */
    orderBy?: grupoOrderByWithRelationInput | grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grupos.
     */
    cursor?: grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grupos.
     */
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[]
  }

  /**
   * grupo findMany
   */
  export type grupoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * Filter, which grupos to fetch.
     */
    where?: grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos to fetch.
     */
    orderBy?: grupoOrderByWithRelationInput | grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing grupos.
     */
    cursor?: grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos.
     */
    skip?: number
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[]
  }

  /**
   * grupo create
   */
  export type grupoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * The data needed to create a grupo.
     */
    data?: XOR<grupoCreateInput, grupoUncheckedCreateInput>
  }

  /**
   * grupo createMany
   */
  export type grupoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many grupos.
     */
    data: grupoCreateManyInput | grupoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * grupo createManyAndReturn
   */
  export type grupoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many grupos.
     */
    data: grupoCreateManyInput | grupoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * grupo update
   */
  export type grupoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * The data needed to update a grupo.
     */
    data: XOR<grupoUpdateInput, grupoUncheckedUpdateInput>
    /**
     * Choose, which grupo to update.
     */
    where: grupoWhereUniqueInput
  }

  /**
   * grupo updateMany
   */
  export type grupoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update grupos.
     */
    data: XOR<grupoUpdateManyMutationInput, grupoUncheckedUpdateManyInput>
    /**
     * Filter which grupos to update
     */
    where?: grupoWhereInput
  }

  /**
   * grupo upsert
   */
  export type grupoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * The filter to search for the grupo to update in case it exists.
     */
    where: grupoWhereUniqueInput
    /**
     * In case the grupo found by the `where` argument doesn't exist, create a new grupo with this data.
     */
    create: XOR<grupoCreateInput, grupoUncheckedCreateInput>
    /**
     * In case the grupo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<grupoUpdateInput, grupoUncheckedUpdateInput>
  }

  /**
   * grupo delete
   */
  export type grupoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
    /**
     * Filter which grupo to delete.
     */
    where: grupoWhereUniqueInput
  }

  /**
   * grupo deleteMany
   */
  export type grupoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grupos to delete
     */
    where?: grupoWhereInput
  }

  /**
   * grupo.Messages
   */
  export type grupo$MessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    where?: MessagesWhereInput
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    cursor?: MessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * grupo.grupos_pessoas
   */
  export type grupo$grupos_pessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos_pessoas
     */
    select?: grupos_pessoasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupos_pessoasInclude<ExtArgs> | null
    where?: grupos_pessoasWhereInput
    orderBy?: grupos_pessoasOrderByWithRelationInput | grupos_pessoasOrderByWithRelationInput[]
    cursor?: grupos_pessoasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Grupos_pessoasScalarFieldEnum | Grupos_pessoasScalarFieldEnum[]
  }

  /**
   * grupo without action
   */
  export type grupoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupoInclude<ExtArgs> | null
  }


  /**
   * Model grupos_pessoas
   */

  export type AggregateGrupos_pessoas = {
    _count: Grupos_pessoasCountAggregateOutputType | null
    _avg: Grupos_pessoasAvgAggregateOutputType | null
    _sum: Grupos_pessoasSumAggregateOutputType | null
    _min: Grupos_pessoasMinAggregateOutputType | null
    _max: Grupos_pessoasMaxAggregateOutputType | null
  }

  export type Grupos_pessoasAvgAggregateOutputType = {
    id: number | null
    id_pessoa: number | null
    id_grupo: number | null
  }

  export type Grupos_pessoasSumAggregateOutputType = {
    id: bigint | null
    id_pessoa: bigint | null
    id_grupo: bigint | null
  }

  export type Grupos_pessoasMinAggregateOutputType = {
    id: bigint | null
    data_cadastro: Date | null
    id_pessoa: bigint | null
    id_grupo: bigint | null
  }

  export type Grupos_pessoasMaxAggregateOutputType = {
    id: bigint | null
    data_cadastro: Date | null
    id_pessoa: bigint | null
    id_grupo: bigint | null
  }

  export type Grupos_pessoasCountAggregateOutputType = {
    id: number
    data_cadastro: number
    id_pessoa: number
    id_grupo: number
    _all: number
  }


  export type Grupos_pessoasAvgAggregateInputType = {
    id?: true
    id_pessoa?: true
    id_grupo?: true
  }

  export type Grupos_pessoasSumAggregateInputType = {
    id?: true
    id_pessoa?: true
    id_grupo?: true
  }

  export type Grupos_pessoasMinAggregateInputType = {
    id?: true
    data_cadastro?: true
    id_pessoa?: true
    id_grupo?: true
  }

  export type Grupos_pessoasMaxAggregateInputType = {
    id?: true
    data_cadastro?: true
    id_pessoa?: true
    id_grupo?: true
  }

  export type Grupos_pessoasCountAggregateInputType = {
    id?: true
    data_cadastro?: true
    id_pessoa?: true
    id_grupo?: true
    _all?: true
  }

  export type Grupos_pessoasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grupos_pessoas to aggregate.
     */
    where?: grupos_pessoasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos_pessoas to fetch.
     */
    orderBy?: grupos_pessoasOrderByWithRelationInput | grupos_pessoasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: grupos_pessoasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos_pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos_pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned grupos_pessoas
    **/
    _count?: true | Grupos_pessoasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Grupos_pessoasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Grupos_pessoasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Grupos_pessoasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Grupos_pessoasMaxAggregateInputType
  }

  export type GetGrupos_pessoasAggregateType<T extends Grupos_pessoasAggregateArgs> = {
        [P in keyof T & keyof AggregateGrupos_pessoas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrupos_pessoas[P]>
      : GetScalarType<T[P], AggregateGrupos_pessoas[P]>
  }




  export type grupos_pessoasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grupos_pessoasWhereInput
    orderBy?: grupos_pessoasOrderByWithAggregationInput | grupos_pessoasOrderByWithAggregationInput[]
    by: Grupos_pessoasScalarFieldEnum[] | Grupos_pessoasScalarFieldEnum
    having?: grupos_pessoasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Grupos_pessoasCountAggregateInputType | true
    _avg?: Grupos_pessoasAvgAggregateInputType
    _sum?: Grupos_pessoasSumAggregateInputType
    _min?: Grupos_pessoasMinAggregateInputType
    _max?: Grupos_pessoasMaxAggregateInputType
  }

  export type Grupos_pessoasGroupByOutputType = {
    id: bigint
    data_cadastro: Date
    id_pessoa: bigint
    id_grupo: bigint
    _count: Grupos_pessoasCountAggregateOutputType | null
    _avg: Grupos_pessoasAvgAggregateOutputType | null
    _sum: Grupos_pessoasSumAggregateOutputType | null
    _min: Grupos_pessoasMinAggregateOutputType | null
    _max: Grupos_pessoasMaxAggregateOutputType | null
  }

  type GetGrupos_pessoasGroupByPayload<T extends grupos_pessoasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Grupos_pessoasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Grupos_pessoasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Grupos_pessoasGroupByOutputType[P]>
            : GetScalarType<T[P], Grupos_pessoasGroupByOutputType[P]>
        }
      >
    >


  export type grupos_pessoasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data_cadastro?: boolean
    id_pessoa?: boolean
    id_grupo?: boolean
    grupo?: boolean | grupoDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grupos_pessoas"]>

  export type grupos_pessoasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    data_cadastro?: boolean
    id_pessoa?: boolean
    id_grupo?: boolean
    grupo?: boolean | grupoDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grupos_pessoas"]>

  export type grupos_pessoasSelectScalar = {
    id?: boolean
    data_cadastro?: boolean
    id_pessoa?: boolean
    id_grupo?: boolean
  }

  export type grupos_pessoasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grupo?: boolean | grupoDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }
  export type grupos_pessoasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grupo?: boolean | grupoDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }

  export type $grupos_pessoasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "grupos_pessoas"
    objects: {
      grupo: Prisma.$grupoPayload<ExtArgs>
      pessoa: Prisma.$pessoaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      data_cadastro: Date
      id_pessoa: bigint
      id_grupo: bigint
    }, ExtArgs["result"]["grupos_pessoas"]>
    composites: {}
  }

  type grupos_pessoasGetPayload<S extends boolean | null | undefined | grupos_pessoasDefaultArgs> = $Result.GetResult<Prisma.$grupos_pessoasPayload, S>

  type grupos_pessoasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<grupos_pessoasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Grupos_pessoasCountAggregateInputType | true
    }

  export interface grupos_pessoasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['grupos_pessoas'], meta: { name: 'grupos_pessoas' } }
    /**
     * Find zero or one Grupos_pessoas that matches the filter.
     * @param {grupos_pessoasFindUniqueArgs} args - Arguments to find a Grupos_pessoas
     * @example
     * // Get one Grupos_pessoas
     * const grupos_pessoas = await prisma.grupos_pessoas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends grupos_pessoasFindUniqueArgs>(args: SelectSubset<T, grupos_pessoasFindUniqueArgs<ExtArgs>>): Prisma__grupos_pessoasClient<$Result.GetResult<Prisma.$grupos_pessoasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Grupos_pessoas that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {grupos_pessoasFindUniqueOrThrowArgs} args - Arguments to find a Grupos_pessoas
     * @example
     * // Get one Grupos_pessoas
     * const grupos_pessoas = await prisma.grupos_pessoas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends grupos_pessoasFindUniqueOrThrowArgs>(args: SelectSubset<T, grupos_pessoasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__grupos_pessoasClient<$Result.GetResult<Prisma.$grupos_pessoasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Grupos_pessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupos_pessoasFindFirstArgs} args - Arguments to find a Grupos_pessoas
     * @example
     * // Get one Grupos_pessoas
     * const grupos_pessoas = await prisma.grupos_pessoas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends grupos_pessoasFindFirstArgs>(args?: SelectSubset<T, grupos_pessoasFindFirstArgs<ExtArgs>>): Prisma__grupos_pessoasClient<$Result.GetResult<Prisma.$grupos_pessoasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Grupos_pessoas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupos_pessoasFindFirstOrThrowArgs} args - Arguments to find a Grupos_pessoas
     * @example
     * // Get one Grupos_pessoas
     * const grupos_pessoas = await prisma.grupos_pessoas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends grupos_pessoasFindFirstOrThrowArgs>(args?: SelectSubset<T, grupos_pessoasFindFirstOrThrowArgs<ExtArgs>>): Prisma__grupos_pessoasClient<$Result.GetResult<Prisma.$grupos_pessoasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Grupos_pessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupos_pessoasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grupos_pessoas
     * const grupos_pessoas = await prisma.grupos_pessoas.findMany()
     * 
     * // Get first 10 Grupos_pessoas
     * const grupos_pessoas = await prisma.grupos_pessoas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const grupos_pessoasWithIdOnly = await prisma.grupos_pessoas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends grupos_pessoasFindManyArgs>(args?: SelectSubset<T, grupos_pessoasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grupos_pessoasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Grupos_pessoas.
     * @param {grupos_pessoasCreateArgs} args - Arguments to create a Grupos_pessoas.
     * @example
     * // Create one Grupos_pessoas
     * const Grupos_pessoas = await prisma.grupos_pessoas.create({
     *   data: {
     *     // ... data to create a Grupos_pessoas
     *   }
     * })
     * 
     */
    create<T extends grupos_pessoasCreateArgs>(args: SelectSubset<T, grupos_pessoasCreateArgs<ExtArgs>>): Prisma__grupos_pessoasClient<$Result.GetResult<Prisma.$grupos_pessoasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Grupos_pessoas.
     * @param {grupos_pessoasCreateManyArgs} args - Arguments to create many Grupos_pessoas.
     * @example
     * // Create many Grupos_pessoas
     * const grupos_pessoas = await prisma.grupos_pessoas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends grupos_pessoasCreateManyArgs>(args?: SelectSubset<T, grupos_pessoasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grupos_pessoas and returns the data saved in the database.
     * @param {grupos_pessoasCreateManyAndReturnArgs} args - Arguments to create many Grupos_pessoas.
     * @example
     * // Create many Grupos_pessoas
     * const grupos_pessoas = await prisma.grupos_pessoas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grupos_pessoas and only return the `id`
     * const grupos_pessoasWithIdOnly = await prisma.grupos_pessoas.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends grupos_pessoasCreateManyAndReturnArgs>(args?: SelectSubset<T, grupos_pessoasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grupos_pessoasPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Grupos_pessoas.
     * @param {grupos_pessoasDeleteArgs} args - Arguments to delete one Grupos_pessoas.
     * @example
     * // Delete one Grupos_pessoas
     * const Grupos_pessoas = await prisma.grupos_pessoas.delete({
     *   where: {
     *     // ... filter to delete one Grupos_pessoas
     *   }
     * })
     * 
     */
    delete<T extends grupos_pessoasDeleteArgs>(args: SelectSubset<T, grupos_pessoasDeleteArgs<ExtArgs>>): Prisma__grupos_pessoasClient<$Result.GetResult<Prisma.$grupos_pessoasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Grupos_pessoas.
     * @param {grupos_pessoasUpdateArgs} args - Arguments to update one Grupos_pessoas.
     * @example
     * // Update one Grupos_pessoas
     * const grupos_pessoas = await prisma.grupos_pessoas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends grupos_pessoasUpdateArgs>(args: SelectSubset<T, grupos_pessoasUpdateArgs<ExtArgs>>): Prisma__grupos_pessoasClient<$Result.GetResult<Prisma.$grupos_pessoasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Grupos_pessoas.
     * @param {grupos_pessoasDeleteManyArgs} args - Arguments to filter Grupos_pessoas to delete.
     * @example
     * // Delete a few Grupos_pessoas
     * const { count } = await prisma.grupos_pessoas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends grupos_pessoasDeleteManyArgs>(args?: SelectSubset<T, grupos_pessoasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grupos_pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupos_pessoasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grupos_pessoas
     * const grupos_pessoas = await prisma.grupos_pessoas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends grupos_pessoasUpdateManyArgs>(args: SelectSubset<T, grupos_pessoasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Grupos_pessoas.
     * @param {grupos_pessoasUpsertArgs} args - Arguments to update or create a Grupos_pessoas.
     * @example
     * // Update or create a Grupos_pessoas
     * const grupos_pessoas = await prisma.grupos_pessoas.upsert({
     *   create: {
     *     // ... data to create a Grupos_pessoas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grupos_pessoas we want to update
     *   }
     * })
     */
    upsert<T extends grupos_pessoasUpsertArgs>(args: SelectSubset<T, grupos_pessoasUpsertArgs<ExtArgs>>): Prisma__grupos_pessoasClient<$Result.GetResult<Prisma.$grupos_pessoasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Grupos_pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupos_pessoasCountArgs} args - Arguments to filter Grupos_pessoas to count.
     * @example
     * // Count the number of Grupos_pessoas
     * const count = await prisma.grupos_pessoas.count({
     *   where: {
     *     // ... the filter for the Grupos_pessoas we want to count
     *   }
     * })
    **/
    count<T extends grupos_pessoasCountArgs>(
      args?: Subset<T, grupos_pessoasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Grupos_pessoasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grupos_pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Grupos_pessoasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Grupos_pessoasAggregateArgs>(args: Subset<T, Grupos_pessoasAggregateArgs>): Prisma.PrismaPromise<GetGrupos_pessoasAggregateType<T>>

    /**
     * Group by Grupos_pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupos_pessoasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends grupos_pessoasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: grupos_pessoasGroupByArgs['orderBy'] }
        : { orderBy?: grupos_pessoasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, grupos_pessoasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrupos_pessoasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the grupos_pessoas model
   */
  readonly fields: grupos_pessoasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for grupos_pessoas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__grupos_pessoasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grupo<T extends grupoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, grupoDefaultArgs<ExtArgs>>): Prisma__grupoClient<$Result.GetResult<Prisma.$grupoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pessoa<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the grupos_pessoas model
   */ 
  interface grupos_pessoasFieldRefs {
    readonly id: FieldRef<"grupos_pessoas", 'BigInt'>
    readonly data_cadastro: FieldRef<"grupos_pessoas", 'DateTime'>
    readonly id_pessoa: FieldRef<"grupos_pessoas", 'BigInt'>
    readonly id_grupo: FieldRef<"grupos_pessoas", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * grupos_pessoas findUnique
   */
  export type grupos_pessoasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos_pessoas
     */
    select?: grupos_pessoasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupos_pessoasInclude<ExtArgs> | null
    /**
     * Filter, which grupos_pessoas to fetch.
     */
    where: grupos_pessoasWhereUniqueInput
  }

  /**
   * grupos_pessoas findUniqueOrThrow
   */
  export type grupos_pessoasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos_pessoas
     */
    select?: grupos_pessoasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupos_pessoasInclude<ExtArgs> | null
    /**
     * Filter, which grupos_pessoas to fetch.
     */
    where: grupos_pessoasWhereUniqueInput
  }

  /**
   * grupos_pessoas findFirst
   */
  export type grupos_pessoasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos_pessoas
     */
    select?: grupos_pessoasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupos_pessoasInclude<ExtArgs> | null
    /**
     * Filter, which grupos_pessoas to fetch.
     */
    where?: grupos_pessoasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos_pessoas to fetch.
     */
    orderBy?: grupos_pessoasOrderByWithRelationInput | grupos_pessoasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grupos_pessoas.
     */
    cursor?: grupos_pessoasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos_pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos_pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grupos_pessoas.
     */
    distinct?: Grupos_pessoasScalarFieldEnum | Grupos_pessoasScalarFieldEnum[]
  }

  /**
   * grupos_pessoas findFirstOrThrow
   */
  export type grupos_pessoasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos_pessoas
     */
    select?: grupos_pessoasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupos_pessoasInclude<ExtArgs> | null
    /**
     * Filter, which grupos_pessoas to fetch.
     */
    where?: grupos_pessoasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos_pessoas to fetch.
     */
    orderBy?: grupos_pessoasOrderByWithRelationInput | grupos_pessoasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grupos_pessoas.
     */
    cursor?: grupos_pessoasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos_pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos_pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grupos_pessoas.
     */
    distinct?: Grupos_pessoasScalarFieldEnum | Grupos_pessoasScalarFieldEnum[]
  }

  /**
   * grupos_pessoas findMany
   */
  export type grupos_pessoasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos_pessoas
     */
    select?: grupos_pessoasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupos_pessoasInclude<ExtArgs> | null
    /**
     * Filter, which grupos_pessoas to fetch.
     */
    where?: grupos_pessoasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grupos_pessoas to fetch.
     */
    orderBy?: grupos_pessoasOrderByWithRelationInput | grupos_pessoasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing grupos_pessoas.
     */
    cursor?: grupos_pessoasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grupos_pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grupos_pessoas.
     */
    skip?: number
    distinct?: Grupos_pessoasScalarFieldEnum | Grupos_pessoasScalarFieldEnum[]
  }

  /**
   * grupos_pessoas create
   */
  export type grupos_pessoasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos_pessoas
     */
    select?: grupos_pessoasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupos_pessoasInclude<ExtArgs> | null
    /**
     * The data needed to create a grupos_pessoas.
     */
    data: XOR<grupos_pessoasCreateInput, grupos_pessoasUncheckedCreateInput>
  }

  /**
   * grupos_pessoas createMany
   */
  export type grupos_pessoasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many grupos_pessoas.
     */
    data: grupos_pessoasCreateManyInput | grupos_pessoasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * grupos_pessoas createManyAndReturn
   */
  export type grupos_pessoasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos_pessoas
     */
    select?: grupos_pessoasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many grupos_pessoas.
     */
    data: grupos_pessoasCreateManyInput | grupos_pessoasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupos_pessoasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * grupos_pessoas update
   */
  export type grupos_pessoasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos_pessoas
     */
    select?: grupos_pessoasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupos_pessoasInclude<ExtArgs> | null
    /**
     * The data needed to update a grupos_pessoas.
     */
    data: XOR<grupos_pessoasUpdateInput, grupos_pessoasUncheckedUpdateInput>
    /**
     * Choose, which grupos_pessoas to update.
     */
    where: grupos_pessoasWhereUniqueInput
  }

  /**
   * grupos_pessoas updateMany
   */
  export type grupos_pessoasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update grupos_pessoas.
     */
    data: XOR<grupos_pessoasUpdateManyMutationInput, grupos_pessoasUncheckedUpdateManyInput>
    /**
     * Filter which grupos_pessoas to update
     */
    where?: grupos_pessoasWhereInput
  }

  /**
   * grupos_pessoas upsert
   */
  export type grupos_pessoasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos_pessoas
     */
    select?: grupos_pessoasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupos_pessoasInclude<ExtArgs> | null
    /**
     * The filter to search for the grupos_pessoas to update in case it exists.
     */
    where: grupos_pessoasWhereUniqueInput
    /**
     * In case the grupos_pessoas found by the `where` argument doesn't exist, create a new grupos_pessoas with this data.
     */
    create: XOR<grupos_pessoasCreateInput, grupos_pessoasUncheckedCreateInput>
    /**
     * In case the grupos_pessoas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<grupos_pessoasUpdateInput, grupos_pessoasUncheckedUpdateInput>
  }

  /**
   * grupos_pessoas delete
   */
  export type grupos_pessoasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos_pessoas
     */
    select?: grupos_pessoasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupos_pessoasInclude<ExtArgs> | null
    /**
     * Filter which grupos_pessoas to delete.
     */
    where: grupos_pessoasWhereUniqueInput
  }

  /**
   * grupos_pessoas deleteMany
   */
  export type grupos_pessoasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grupos_pessoas to delete
     */
    where?: grupos_pessoasWhereInput
  }

  /**
   * grupos_pessoas without action
   */
  export type grupos_pessoasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos_pessoas
     */
    select?: grupos_pessoasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupos_pessoasInclude<ExtArgs> | null
  }


  /**
   * Model mensagem_grupo
   */

  export type AggregateMensagem_grupo = {
    _count: Mensagem_grupoCountAggregateOutputType | null
    _avg: Mensagem_grupoAvgAggregateOutputType | null
    _sum: Mensagem_grupoSumAggregateOutputType | null
    _min: Mensagem_grupoMinAggregateOutputType | null
    _max: Mensagem_grupoMaxAggregateOutputType | null
  }

  export type Mensagem_grupoAvgAggregateOutputType = {
    id: number | null
    id_Messages: number | null
    id_pessoa: number | null
  }

  export type Mensagem_grupoSumAggregateOutputType = {
    id: bigint | null
    id_Messages: bigint | null
    id_pessoa: bigint | null
  }

  export type Mensagem_grupoMinAggregateOutputType = {
    id: bigint | null
    mensagem: string | null
    data_cadastro: Date | null
    id_Messages: bigint | null
    id_pessoa: bigint | null
  }

  export type Mensagem_grupoMaxAggregateOutputType = {
    id: bigint | null
    mensagem: string | null
    data_cadastro: Date | null
    id_Messages: bigint | null
    id_pessoa: bigint | null
  }

  export type Mensagem_grupoCountAggregateOutputType = {
    id: number
    mensagem: number
    data_cadastro: number
    id_Messages: number
    id_pessoa: number
    _all: number
  }


  export type Mensagem_grupoAvgAggregateInputType = {
    id?: true
    id_Messages?: true
    id_pessoa?: true
  }

  export type Mensagem_grupoSumAggregateInputType = {
    id?: true
    id_Messages?: true
    id_pessoa?: true
  }

  export type Mensagem_grupoMinAggregateInputType = {
    id?: true
    mensagem?: true
    data_cadastro?: true
    id_Messages?: true
    id_pessoa?: true
  }

  export type Mensagem_grupoMaxAggregateInputType = {
    id?: true
    mensagem?: true
    data_cadastro?: true
    id_Messages?: true
    id_pessoa?: true
  }

  export type Mensagem_grupoCountAggregateInputType = {
    id?: true
    mensagem?: true
    data_cadastro?: true
    id_Messages?: true
    id_pessoa?: true
    _all?: true
  }

  export type Mensagem_grupoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mensagem_grupo to aggregate.
     */
    where?: mensagem_grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mensagem_grupos to fetch.
     */
    orderBy?: mensagem_grupoOrderByWithRelationInput | mensagem_grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mensagem_grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mensagem_grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mensagem_grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mensagem_grupos
    **/
    _count?: true | Mensagem_grupoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mensagem_grupoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mensagem_grupoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mensagem_grupoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mensagem_grupoMaxAggregateInputType
  }

  export type GetMensagem_grupoAggregateType<T extends Mensagem_grupoAggregateArgs> = {
        [P in keyof T & keyof AggregateMensagem_grupo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMensagem_grupo[P]>
      : GetScalarType<T[P], AggregateMensagem_grupo[P]>
  }




  export type mensagem_grupoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mensagem_grupoWhereInput
    orderBy?: mensagem_grupoOrderByWithAggregationInput | mensagem_grupoOrderByWithAggregationInput[]
    by: Mensagem_grupoScalarFieldEnum[] | Mensagem_grupoScalarFieldEnum
    having?: mensagem_grupoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mensagem_grupoCountAggregateInputType | true
    _avg?: Mensagem_grupoAvgAggregateInputType
    _sum?: Mensagem_grupoSumAggregateInputType
    _min?: Mensagem_grupoMinAggregateInputType
    _max?: Mensagem_grupoMaxAggregateInputType
  }

  export type Mensagem_grupoGroupByOutputType = {
    id: bigint
    mensagem: string
    data_cadastro: Date
    id_Messages: bigint
    id_pessoa: bigint
    _count: Mensagem_grupoCountAggregateOutputType | null
    _avg: Mensagem_grupoAvgAggregateOutputType | null
    _sum: Mensagem_grupoSumAggregateOutputType | null
    _min: Mensagem_grupoMinAggregateOutputType | null
    _max: Mensagem_grupoMaxAggregateOutputType | null
  }

  type GetMensagem_grupoGroupByPayload<T extends mensagem_grupoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mensagem_grupoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mensagem_grupoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mensagem_grupoGroupByOutputType[P]>
            : GetScalarType<T[P], Mensagem_grupoGroupByOutputType[P]>
        }
      >
    >


  export type mensagem_grupoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensagem?: boolean
    data_cadastro?: boolean
    id_Messages?: boolean
    id_pessoa?: boolean
    Messages?: boolean | MessagesDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mensagem_grupo"]>

  export type mensagem_grupoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensagem?: boolean
    data_cadastro?: boolean
    id_Messages?: boolean
    id_pessoa?: boolean
    Messages?: boolean | MessagesDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mensagem_grupo"]>

  export type mensagem_grupoSelectScalar = {
    id?: boolean
    mensagem?: boolean
    data_cadastro?: boolean
    id_Messages?: boolean
    id_pessoa?: boolean
  }

  export type mensagem_grupoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Messages?: boolean | MessagesDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }
  export type mensagem_grupoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Messages?: boolean | MessagesDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }

  export type $mensagem_grupoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mensagem_grupo"
    objects: {
      Messages: Prisma.$MessagesPayload<ExtArgs>
      pessoa: Prisma.$pessoaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      mensagem: string
      data_cadastro: Date
      id_Messages: bigint
      id_pessoa: bigint
    }, ExtArgs["result"]["mensagem_grupo"]>
    composites: {}
  }

  type mensagem_grupoGetPayload<S extends boolean | null | undefined | mensagem_grupoDefaultArgs> = $Result.GetResult<Prisma.$mensagem_grupoPayload, S>

  type mensagem_grupoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<mensagem_grupoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Mensagem_grupoCountAggregateInputType | true
    }

  export interface mensagem_grupoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mensagem_grupo'], meta: { name: 'mensagem_grupo' } }
    /**
     * Find zero or one Mensagem_grupo that matches the filter.
     * @param {mensagem_grupoFindUniqueArgs} args - Arguments to find a Mensagem_grupo
     * @example
     * // Get one Mensagem_grupo
     * const mensagem_grupo = await prisma.mensagem_grupo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mensagem_grupoFindUniqueArgs>(args: SelectSubset<T, mensagem_grupoFindUniqueArgs<ExtArgs>>): Prisma__mensagem_grupoClient<$Result.GetResult<Prisma.$mensagem_grupoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mensagem_grupo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {mensagem_grupoFindUniqueOrThrowArgs} args - Arguments to find a Mensagem_grupo
     * @example
     * // Get one Mensagem_grupo
     * const mensagem_grupo = await prisma.mensagem_grupo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mensagem_grupoFindUniqueOrThrowArgs>(args: SelectSubset<T, mensagem_grupoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mensagem_grupoClient<$Result.GetResult<Prisma.$mensagem_grupoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mensagem_grupo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagem_grupoFindFirstArgs} args - Arguments to find a Mensagem_grupo
     * @example
     * // Get one Mensagem_grupo
     * const mensagem_grupo = await prisma.mensagem_grupo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mensagem_grupoFindFirstArgs>(args?: SelectSubset<T, mensagem_grupoFindFirstArgs<ExtArgs>>): Prisma__mensagem_grupoClient<$Result.GetResult<Prisma.$mensagem_grupoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mensagem_grupo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagem_grupoFindFirstOrThrowArgs} args - Arguments to find a Mensagem_grupo
     * @example
     * // Get one Mensagem_grupo
     * const mensagem_grupo = await prisma.mensagem_grupo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mensagem_grupoFindFirstOrThrowArgs>(args?: SelectSubset<T, mensagem_grupoFindFirstOrThrowArgs<ExtArgs>>): Prisma__mensagem_grupoClient<$Result.GetResult<Prisma.$mensagem_grupoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mensagem_grupos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagem_grupoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mensagem_grupos
     * const mensagem_grupos = await prisma.mensagem_grupo.findMany()
     * 
     * // Get first 10 Mensagem_grupos
     * const mensagem_grupos = await prisma.mensagem_grupo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mensagem_grupoWithIdOnly = await prisma.mensagem_grupo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mensagem_grupoFindManyArgs>(args?: SelectSubset<T, mensagem_grupoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mensagem_grupoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mensagem_grupo.
     * @param {mensagem_grupoCreateArgs} args - Arguments to create a Mensagem_grupo.
     * @example
     * // Create one Mensagem_grupo
     * const Mensagem_grupo = await prisma.mensagem_grupo.create({
     *   data: {
     *     // ... data to create a Mensagem_grupo
     *   }
     * })
     * 
     */
    create<T extends mensagem_grupoCreateArgs>(args: SelectSubset<T, mensagem_grupoCreateArgs<ExtArgs>>): Prisma__mensagem_grupoClient<$Result.GetResult<Prisma.$mensagem_grupoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mensagem_grupos.
     * @param {mensagem_grupoCreateManyArgs} args - Arguments to create many Mensagem_grupos.
     * @example
     * // Create many Mensagem_grupos
     * const mensagem_grupo = await prisma.mensagem_grupo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mensagem_grupoCreateManyArgs>(args?: SelectSubset<T, mensagem_grupoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mensagem_grupos and returns the data saved in the database.
     * @param {mensagem_grupoCreateManyAndReturnArgs} args - Arguments to create many Mensagem_grupos.
     * @example
     * // Create many Mensagem_grupos
     * const mensagem_grupo = await prisma.mensagem_grupo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mensagem_grupos and only return the `id`
     * const mensagem_grupoWithIdOnly = await prisma.mensagem_grupo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mensagem_grupoCreateManyAndReturnArgs>(args?: SelectSubset<T, mensagem_grupoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mensagem_grupoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mensagem_grupo.
     * @param {mensagem_grupoDeleteArgs} args - Arguments to delete one Mensagem_grupo.
     * @example
     * // Delete one Mensagem_grupo
     * const Mensagem_grupo = await prisma.mensagem_grupo.delete({
     *   where: {
     *     // ... filter to delete one Mensagem_grupo
     *   }
     * })
     * 
     */
    delete<T extends mensagem_grupoDeleteArgs>(args: SelectSubset<T, mensagem_grupoDeleteArgs<ExtArgs>>): Prisma__mensagem_grupoClient<$Result.GetResult<Prisma.$mensagem_grupoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mensagem_grupo.
     * @param {mensagem_grupoUpdateArgs} args - Arguments to update one Mensagem_grupo.
     * @example
     * // Update one Mensagem_grupo
     * const mensagem_grupo = await prisma.mensagem_grupo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mensagem_grupoUpdateArgs>(args: SelectSubset<T, mensagem_grupoUpdateArgs<ExtArgs>>): Prisma__mensagem_grupoClient<$Result.GetResult<Prisma.$mensagem_grupoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mensagem_grupos.
     * @param {mensagem_grupoDeleteManyArgs} args - Arguments to filter Mensagem_grupos to delete.
     * @example
     * // Delete a few Mensagem_grupos
     * const { count } = await prisma.mensagem_grupo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mensagem_grupoDeleteManyArgs>(args?: SelectSubset<T, mensagem_grupoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mensagem_grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagem_grupoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mensagem_grupos
     * const mensagem_grupo = await prisma.mensagem_grupo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mensagem_grupoUpdateManyArgs>(args: SelectSubset<T, mensagem_grupoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mensagem_grupo.
     * @param {mensagem_grupoUpsertArgs} args - Arguments to update or create a Mensagem_grupo.
     * @example
     * // Update or create a Mensagem_grupo
     * const mensagem_grupo = await prisma.mensagem_grupo.upsert({
     *   create: {
     *     // ... data to create a Mensagem_grupo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mensagem_grupo we want to update
     *   }
     * })
     */
    upsert<T extends mensagem_grupoUpsertArgs>(args: SelectSubset<T, mensagem_grupoUpsertArgs<ExtArgs>>): Prisma__mensagem_grupoClient<$Result.GetResult<Prisma.$mensagem_grupoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mensagem_grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagem_grupoCountArgs} args - Arguments to filter Mensagem_grupos to count.
     * @example
     * // Count the number of Mensagem_grupos
     * const count = await prisma.mensagem_grupo.count({
     *   where: {
     *     // ... the filter for the Mensagem_grupos we want to count
     *   }
     * })
    **/
    count<T extends mensagem_grupoCountArgs>(
      args?: Subset<T, mensagem_grupoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mensagem_grupoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mensagem_grupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mensagem_grupoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mensagem_grupoAggregateArgs>(args: Subset<T, Mensagem_grupoAggregateArgs>): Prisma.PrismaPromise<GetMensagem_grupoAggregateType<T>>

    /**
     * Group by Mensagem_grupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagem_grupoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mensagem_grupoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mensagem_grupoGroupByArgs['orderBy'] }
        : { orderBy?: mensagem_grupoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mensagem_grupoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMensagem_grupoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mensagem_grupo model
   */
  readonly fields: mensagem_grupoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mensagem_grupo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mensagem_grupoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Messages<T extends MessagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessagesDefaultArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pessoa<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mensagem_grupo model
   */ 
  interface mensagem_grupoFieldRefs {
    readonly id: FieldRef<"mensagem_grupo", 'BigInt'>
    readonly mensagem: FieldRef<"mensagem_grupo", 'String'>
    readonly data_cadastro: FieldRef<"mensagem_grupo", 'DateTime'>
    readonly id_Messages: FieldRef<"mensagem_grupo", 'BigInt'>
    readonly id_pessoa: FieldRef<"mensagem_grupo", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * mensagem_grupo findUnique
   */
  export type mensagem_grupoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_grupo
     */
    select?: mensagem_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_grupoInclude<ExtArgs> | null
    /**
     * Filter, which mensagem_grupo to fetch.
     */
    where: mensagem_grupoWhereUniqueInput
  }

  /**
   * mensagem_grupo findUniqueOrThrow
   */
  export type mensagem_grupoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_grupo
     */
    select?: mensagem_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_grupoInclude<ExtArgs> | null
    /**
     * Filter, which mensagem_grupo to fetch.
     */
    where: mensagem_grupoWhereUniqueInput
  }

  /**
   * mensagem_grupo findFirst
   */
  export type mensagem_grupoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_grupo
     */
    select?: mensagem_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_grupoInclude<ExtArgs> | null
    /**
     * Filter, which mensagem_grupo to fetch.
     */
    where?: mensagem_grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mensagem_grupos to fetch.
     */
    orderBy?: mensagem_grupoOrderByWithRelationInput | mensagem_grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mensagem_grupos.
     */
    cursor?: mensagem_grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mensagem_grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mensagem_grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mensagem_grupos.
     */
    distinct?: Mensagem_grupoScalarFieldEnum | Mensagem_grupoScalarFieldEnum[]
  }

  /**
   * mensagem_grupo findFirstOrThrow
   */
  export type mensagem_grupoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_grupo
     */
    select?: mensagem_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_grupoInclude<ExtArgs> | null
    /**
     * Filter, which mensagem_grupo to fetch.
     */
    where?: mensagem_grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mensagem_grupos to fetch.
     */
    orderBy?: mensagem_grupoOrderByWithRelationInput | mensagem_grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mensagem_grupos.
     */
    cursor?: mensagem_grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mensagem_grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mensagem_grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mensagem_grupos.
     */
    distinct?: Mensagem_grupoScalarFieldEnum | Mensagem_grupoScalarFieldEnum[]
  }

  /**
   * mensagem_grupo findMany
   */
  export type mensagem_grupoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_grupo
     */
    select?: mensagem_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_grupoInclude<ExtArgs> | null
    /**
     * Filter, which mensagem_grupos to fetch.
     */
    where?: mensagem_grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mensagem_grupos to fetch.
     */
    orderBy?: mensagem_grupoOrderByWithRelationInput | mensagem_grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mensagem_grupos.
     */
    cursor?: mensagem_grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mensagem_grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mensagem_grupos.
     */
    skip?: number
    distinct?: Mensagem_grupoScalarFieldEnum | Mensagem_grupoScalarFieldEnum[]
  }

  /**
   * mensagem_grupo create
   */
  export type mensagem_grupoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_grupo
     */
    select?: mensagem_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_grupoInclude<ExtArgs> | null
    /**
     * The data needed to create a mensagem_grupo.
     */
    data: XOR<mensagem_grupoCreateInput, mensagem_grupoUncheckedCreateInput>
  }

  /**
   * mensagem_grupo createMany
   */
  export type mensagem_grupoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mensagem_grupos.
     */
    data: mensagem_grupoCreateManyInput | mensagem_grupoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mensagem_grupo createManyAndReturn
   */
  export type mensagem_grupoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_grupo
     */
    select?: mensagem_grupoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many mensagem_grupos.
     */
    data: mensagem_grupoCreateManyInput | mensagem_grupoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_grupoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mensagem_grupo update
   */
  export type mensagem_grupoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_grupo
     */
    select?: mensagem_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_grupoInclude<ExtArgs> | null
    /**
     * The data needed to update a mensagem_grupo.
     */
    data: XOR<mensagem_grupoUpdateInput, mensagem_grupoUncheckedUpdateInput>
    /**
     * Choose, which mensagem_grupo to update.
     */
    where: mensagem_grupoWhereUniqueInput
  }

  /**
   * mensagem_grupo updateMany
   */
  export type mensagem_grupoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mensagem_grupos.
     */
    data: XOR<mensagem_grupoUpdateManyMutationInput, mensagem_grupoUncheckedUpdateManyInput>
    /**
     * Filter which mensagem_grupos to update
     */
    where?: mensagem_grupoWhereInput
  }

  /**
   * mensagem_grupo upsert
   */
  export type mensagem_grupoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_grupo
     */
    select?: mensagem_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_grupoInclude<ExtArgs> | null
    /**
     * The filter to search for the mensagem_grupo to update in case it exists.
     */
    where: mensagem_grupoWhereUniqueInput
    /**
     * In case the mensagem_grupo found by the `where` argument doesn't exist, create a new mensagem_grupo with this data.
     */
    create: XOR<mensagem_grupoCreateInput, mensagem_grupoUncheckedCreateInput>
    /**
     * In case the mensagem_grupo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mensagem_grupoUpdateInput, mensagem_grupoUncheckedUpdateInput>
  }

  /**
   * mensagem_grupo delete
   */
  export type mensagem_grupoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_grupo
     */
    select?: mensagem_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_grupoInclude<ExtArgs> | null
    /**
     * Filter which mensagem_grupo to delete.
     */
    where: mensagem_grupoWhereUniqueInput
  }

  /**
   * mensagem_grupo deleteMany
   */
  export type mensagem_grupoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mensagem_grupos to delete
     */
    where?: mensagem_grupoWhereInput
  }

  /**
   * mensagem_grupo without action
   */
  export type mensagem_grupoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_grupo
     */
    select?: mensagem_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_grupoInclude<ExtArgs> | null
  }


  /**
   * Model mensagem_privada
   */

  export type AggregateMensagem_privada = {
    _count: Mensagem_privadaCountAggregateOutputType | null
    _avg: Mensagem_privadaAvgAggregateOutputType | null
    _sum: Mensagem_privadaSumAggregateOutputType | null
    _min: Mensagem_privadaMinAggregateOutputType | null
    _max: Mensagem_privadaMaxAggregateOutputType | null
  }

  export type Mensagem_privadaAvgAggregateOutputType = {
    id: number | null
    id_Messages: number | null
    id_pessoa: number | null
  }

  export type Mensagem_privadaSumAggregateOutputType = {
    id: bigint | null
    id_Messages: bigint | null
    id_pessoa: bigint | null
  }

  export type Mensagem_privadaMinAggregateOutputType = {
    id: bigint | null
    mensagem: string | null
    data_cadastro: Date | null
    id_Messages: bigint | null
    id_pessoa: bigint | null
  }

  export type Mensagem_privadaMaxAggregateOutputType = {
    id: bigint | null
    mensagem: string | null
    data_cadastro: Date | null
    id_Messages: bigint | null
    id_pessoa: bigint | null
  }

  export type Mensagem_privadaCountAggregateOutputType = {
    id: number
    mensagem: number
    data_cadastro: number
    id_Messages: number
    id_pessoa: number
    _all: number
  }


  export type Mensagem_privadaAvgAggregateInputType = {
    id?: true
    id_Messages?: true
    id_pessoa?: true
  }

  export type Mensagem_privadaSumAggregateInputType = {
    id?: true
    id_Messages?: true
    id_pessoa?: true
  }

  export type Mensagem_privadaMinAggregateInputType = {
    id?: true
    mensagem?: true
    data_cadastro?: true
    id_Messages?: true
    id_pessoa?: true
  }

  export type Mensagem_privadaMaxAggregateInputType = {
    id?: true
    mensagem?: true
    data_cadastro?: true
    id_Messages?: true
    id_pessoa?: true
  }

  export type Mensagem_privadaCountAggregateInputType = {
    id?: true
    mensagem?: true
    data_cadastro?: true
    id_Messages?: true
    id_pessoa?: true
    _all?: true
  }

  export type Mensagem_privadaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mensagem_privada to aggregate.
     */
    where?: mensagem_privadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mensagem_privadas to fetch.
     */
    orderBy?: mensagem_privadaOrderByWithRelationInput | mensagem_privadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mensagem_privadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mensagem_privadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mensagem_privadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mensagem_privadas
    **/
    _count?: true | Mensagem_privadaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mensagem_privadaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mensagem_privadaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mensagem_privadaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mensagem_privadaMaxAggregateInputType
  }

  export type GetMensagem_privadaAggregateType<T extends Mensagem_privadaAggregateArgs> = {
        [P in keyof T & keyof AggregateMensagem_privada]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMensagem_privada[P]>
      : GetScalarType<T[P], AggregateMensagem_privada[P]>
  }




  export type mensagem_privadaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mensagem_privadaWhereInput
    orderBy?: mensagem_privadaOrderByWithAggregationInput | mensagem_privadaOrderByWithAggregationInput[]
    by: Mensagem_privadaScalarFieldEnum[] | Mensagem_privadaScalarFieldEnum
    having?: mensagem_privadaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mensagem_privadaCountAggregateInputType | true
    _avg?: Mensagem_privadaAvgAggregateInputType
    _sum?: Mensagem_privadaSumAggregateInputType
    _min?: Mensagem_privadaMinAggregateInputType
    _max?: Mensagem_privadaMaxAggregateInputType
  }

  export type Mensagem_privadaGroupByOutputType = {
    id: bigint
    mensagem: string
    data_cadastro: Date
    id_Messages: bigint
    id_pessoa: bigint
    _count: Mensagem_privadaCountAggregateOutputType | null
    _avg: Mensagem_privadaAvgAggregateOutputType | null
    _sum: Mensagem_privadaSumAggregateOutputType | null
    _min: Mensagem_privadaMinAggregateOutputType | null
    _max: Mensagem_privadaMaxAggregateOutputType | null
  }

  type GetMensagem_privadaGroupByPayload<T extends mensagem_privadaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mensagem_privadaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mensagem_privadaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mensagem_privadaGroupByOutputType[P]>
            : GetScalarType<T[P], Mensagem_privadaGroupByOutputType[P]>
        }
      >
    >


  export type mensagem_privadaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensagem?: boolean
    data_cadastro?: boolean
    id_Messages?: boolean
    id_pessoa?: boolean
    Messages?: boolean | MessagesDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mensagem_privada"]>

  export type mensagem_privadaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensagem?: boolean
    data_cadastro?: boolean
    id_Messages?: boolean
    id_pessoa?: boolean
    Messages?: boolean | MessagesDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mensagem_privada"]>

  export type mensagem_privadaSelectScalar = {
    id?: boolean
    mensagem?: boolean
    data_cadastro?: boolean
    id_Messages?: boolean
    id_pessoa?: boolean
  }

  export type mensagem_privadaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Messages?: boolean | MessagesDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }
  export type mensagem_privadaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Messages?: boolean | MessagesDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }

  export type $mensagem_privadaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mensagem_privada"
    objects: {
      Messages: Prisma.$MessagesPayload<ExtArgs>
      pessoa: Prisma.$pessoaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      mensagem: string
      data_cadastro: Date
      id_Messages: bigint
      id_pessoa: bigint
    }, ExtArgs["result"]["mensagem_privada"]>
    composites: {}
  }

  type mensagem_privadaGetPayload<S extends boolean | null | undefined | mensagem_privadaDefaultArgs> = $Result.GetResult<Prisma.$mensagem_privadaPayload, S>

  type mensagem_privadaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<mensagem_privadaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Mensagem_privadaCountAggregateInputType | true
    }

  export interface mensagem_privadaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mensagem_privada'], meta: { name: 'mensagem_privada' } }
    /**
     * Find zero or one Mensagem_privada that matches the filter.
     * @param {mensagem_privadaFindUniqueArgs} args - Arguments to find a Mensagem_privada
     * @example
     * // Get one Mensagem_privada
     * const mensagem_privada = await prisma.mensagem_privada.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mensagem_privadaFindUniqueArgs>(args: SelectSubset<T, mensagem_privadaFindUniqueArgs<ExtArgs>>): Prisma__mensagem_privadaClient<$Result.GetResult<Prisma.$mensagem_privadaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mensagem_privada that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {mensagem_privadaFindUniqueOrThrowArgs} args - Arguments to find a Mensagem_privada
     * @example
     * // Get one Mensagem_privada
     * const mensagem_privada = await prisma.mensagem_privada.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mensagem_privadaFindUniqueOrThrowArgs>(args: SelectSubset<T, mensagem_privadaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mensagem_privadaClient<$Result.GetResult<Prisma.$mensagem_privadaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mensagem_privada that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagem_privadaFindFirstArgs} args - Arguments to find a Mensagem_privada
     * @example
     * // Get one Mensagem_privada
     * const mensagem_privada = await prisma.mensagem_privada.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mensagem_privadaFindFirstArgs>(args?: SelectSubset<T, mensagem_privadaFindFirstArgs<ExtArgs>>): Prisma__mensagem_privadaClient<$Result.GetResult<Prisma.$mensagem_privadaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mensagem_privada that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagem_privadaFindFirstOrThrowArgs} args - Arguments to find a Mensagem_privada
     * @example
     * // Get one Mensagem_privada
     * const mensagem_privada = await prisma.mensagem_privada.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mensagem_privadaFindFirstOrThrowArgs>(args?: SelectSubset<T, mensagem_privadaFindFirstOrThrowArgs<ExtArgs>>): Prisma__mensagem_privadaClient<$Result.GetResult<Prisma.$mensagem_privadaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mensagem_privadas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagem_privadaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mensagem_privadas
     * const mensagem_privadas = await prisma.mensagem_privada.findMany()
     * 
     * // Get first 10 Mensagem_privadas
     * const mensagem_privadas = await prisma.mensagem_privada.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mensagem_privadaWithIdOnly = await prisma.mensagem_privada.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mensagem_privadaFindManyArgs>(args?: SelectSubset<T, mensagem_privadaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mensagem_privadaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mensagem_privada.
     * @param {mensagem_privadaCreateArgs} args - Arguments to create a Mensagem_privada.
     * @example
     * // Create one Mensagem_privada
     * const Mensagem_privada = await prisma.mensagem_privada.create({
     *   data: {
     *     // ... data to create a Mensagem_privada
     *   }
     * })
     * 
     */
    create<T extends mensagem_privadaCreateArgs>(args: SelectSubset<T, mensagem_privadaCreateArgs<ExtArgs>>): Prisma__mensagem_privadaClient<$Result.GetResult<Prisma.$mensagem_privadaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mensagem_privadas.
     * @param {mensagem_privadaCreateManyArgs} args - Arguments to create many Mensagem_privadas.
     * @example
     * // Create many Mensagem_privadas
     * const mensagem_privada = await prisma.mensagem_privada.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mensagem_privadaCreateManyArgs>(args?: SelectSubset<T, mensagem_privadaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mensagem_privadas and returns the data saved in the database.
     * @param {mensagem_privadaCreateManyAndReturnArgs} args - Arguments to create many Mensagem_privadas.
     * @example
     * // Create many Mensagem_privadas
     * const mensagem_privada = await prisma.mensagem_privada.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mensagem_privadas and only return the `id`
     * const mensagem_privadaWithIdOnly = await prisma.mensagem_privada.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mensagem_privadaCreateManyAndReturnArgs>(args?: SelectSubset<T, mensagem_privadaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mensagem_privadaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mensagem_privada.
     * @param {mensagem_privadaDeleteArgs} args - Arguments to delete one Mensagem_privada.
     * @example
     * // Delete one Mensagem_privada
     * const Mensagem_privada = await prisma.mensagem_privada.delete({
     *   where: {
     *     // ... filter to delete one Mensagem_privada
     *   }
     * })
     * 
     */
    delete<T extends mensagem_privadaDeleteArgs>(args: SelectSubset<T, mensagem_privadaDeleteArgs<ExtArgs>>): Prisma__mensagem_privadaClient<$Result.GetResult<Prisma.$mensagem_privadaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mensagem_privada.
     * @param {mensagem_privadaUpdateArgs} args - Arguments to update one Mensagem_privada.
     * @example
     * // Update one Mensagem_privada
     * const mensagem_privada = await prisma.mensagem_privada.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mensagem_privadaUpdateArgs>(args: SelectSubset<T, mensagem_privadaUpdateArgs<ExtArgs>>): Prisma__mensagem_privadaClient<$Result.GetResult<Prisma.$mensagem_privadaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mensagem_privadas.
     * @param {mensagem_privadaDeleteManyArgs} args - Arguments to filter Mensagem_privadas to delete.
     * @example
     * // Delete a few Mensagem_privadas
     * const { count } = await prisma.mensagem_privada.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mensagem_privadaDeleteManyArgs>(args?: SelectSubset<T, mensagem_privadaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mensagem_privadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagem_privadaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mensagem_privadas
     * const mensagem_privada = await prisma.mensagem_privada.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mensagem_privadaUpdateManyArgs>(args: SelectSubset<T, mensagem_privadaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mensagem_privada.
     * @param {mensagem_privadaUpsertArgs} args - Arguments to update or create a Mensagem_privada.
     * @example
     * // Update or create a Mensagem_privada
     * const mensagem_privada = await prisma.mensagem_privada.upsert({
     *   create: {
     *     // ... data to create a Mensagem_privada
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mensagem_privada we want to update
     *   }
     * })
     */
    upsert<T extends mensagem_privadaUpsertArgs>(args: SelectSubset<T, mensagem_privadaUpsertArgs<ExtArgs>>): Prisma__mensagem_privadaClient<$Result.GetResult<Prisma.$mensagem_privadaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mensagem_privadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagem_privadaCountArgs} args - Arguments to filter Mensagem_privadas to count.
     * @example
     * // Count the number of Mensagem_privadas
     * const count = await prisma.mensagem_privada.count({
     *   where: {
     *     // ... the filter for the Mensagem_privadas we want to count
     *   }
     * })
    **/
    count<T extends mensagem_privadaCountArgs>(
      args?: Subset<T, mensagem_privadaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mensagem_privadaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mensagem_privada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mensagem_privadaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mensagem_privadaAggregateArgs>(args: Subset<T, Mensagem_privadaAggregateArgs>): Prisma.PrismaPromise<GetMensagem_privadaAggregateType<T>>

    /**
     * Group by Mensagem_privada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagem_privadaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mensagem_privadaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mensagem_privadaGroupByArgs['orderBy'] }
        : { orderBy?: mensagem_privadaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mensagem_privadaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMensagem_privadaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mensagem_privada model
   */
  readonly fields: mensagem_privadaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mensagem_privada.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mensagem_privadaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Messages<T extends MessagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessagesDefaultArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pessoa<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mensagem_privada model
   */ 
  interface mensagem_privadaFieldRefs {
    readonly id: FieldRef<"mensagem_privada", 'BigInt'>
    readonly mensagem: FieldRef<"mensagem_privada", 'String'>
    readonly data_cadastro: FieldRef<"mensagem_privada", 'DateTime'>
    readonly id_Messages: FieldRef<"mensagem_privada", 'BigInt'>
    readonly id_pessoa: FieldRef<"mensagem_privada", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * mensagem_privada findUnique
   */
  export type mensagem_privadaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_privada
     */
    select?: mensagem_privadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_privadaInclude<ExtArgs> | null
    /**
     * Filter, which mensagem_privada to fetch.
     */
    where: mensagem_privadaWhereUniqueInput
  }

  /**
   * mensagem_privada findUniqueOrThrow
   */
  export type mensagem_privadaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_privada
     */
    select?: mensagem_privadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_privadaInclude<ExtArgs> | null
    /**
     * Filter, which mensagem_privada to fetch.
     */
    where: mensagem_privadaWhereUniqueInput
  }

  /**
   * mensagem_privada findFirst
   */
  export type mensagem_privadaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_privada
     */
    select?: mensagem_privadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_privadaInclude<ExtArgs> | null
    /**
     * Filter, which mensagem_privada to fetch.
     */
    where?: mensagem_privadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mensagem_privadas to fetch.
     */
    orderBy?: mensagem_privadaOrderByWithRelationInput | mensagem_privadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mensagem_privadas.
     */
    cursor?: mensagem_privadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mensagem_privadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mensagem_privadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mensagem_privadas.
     */
    distinct?: Mensagem_privadaScalarFieldEnum | Mensagem_privadaScalarFieldEnum[]
  }

  /**
   * mensagem_privada findFirstOrThrow
   */
  export type mensagem_privadaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_privada
     */
    select?: mensagem_privadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_privadaInclude<ExtArgs> | null
    /**
     * Filter, which mensagem_privada to fetch.
     */
    where?: mensagem_privadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mensagem_privadas to fetch.
     */
    orderBy?: mensagem_privadaOrderByWithRelationInput | mensagem_privadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mensagem_privadas.
     */
    cursor?: mensagem_privadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mensagem_privadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mensagem_privadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mensagem_privadas.
     */
    distinct?: Mensagem_privadaScalarFieldEnum | Mensagem_privadaScalarFieldEnum[]
  }

  /**
   * mensagem_privada findMany
   */
  export type mensagem_privadaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_privada
     */
    select?: mensagem_privadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_privadaInclude<ExtArgs> | null
    /**
     * Filter, which mensagem_privadas to fetch.
     */
    where?: mensagem_privadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mensagem_privadas to fetch.
     */
    orderBy?: mensagem_privadaOrderByWithRelationInput | mensagem_privadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mensagem_privadas.
     */
    cursor?: mensagem_privadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mensagem_privadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mensagem_privadas.
     */
    skip?: number
    distinct?: Mensagem_privadaScalarFieldEnum | Mensagem_privadaScalarFieldEnum[]
  }

  /**
   * mensagem_privada create
   */
  export type mensagem_privadaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_privada
     */
    select?: mensagem_privadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_privadaInclude<ExtArgs> | null
    /**
     * The data needed to create a mensagem_privada.
     */
    data: XOR<mensagem_privadaCreateInput, mensagem_privadaUncheckedCreateInput>
  }

  /**
   * mensagem_privada createMany
   */
  export type mensagem_privadaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mensagem_privadas.
     */
    data: mensagem_privadaCreateManyInput | mensagem_privadaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mensagem_privada createManyAndReturn
   */
  export type mensagem_privadaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_privada
     */
    select?: mensagem_privadaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many mensagem_privadas.
     */
    data: mensagem_privadaCreateManyInput | mensagem_privadaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_privadaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mensagem_privada update
   */
  export type mensagem_privadaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_privada
     */
    select?: mensagem_privadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_privadaInclude<ExtArgs> | null
    /**
     * The data needed to update a mensagem_privada.
     */
    data: XOR<mensagem_privadaUpdateInput, mensagem_privadaUncheckedUpdateInput>
    /**
     * Choose, which mensagem_privada to update.
     */
    where: mensagem_privadaWhereUniqueInput
  }

  /**
   * mensagem_privada updateMany
   */
  export type mensagem_privadaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mensagem_privadas.
     */
    data: XOR<mensagem_privadaUpdateManyMutationInput, mensagem_privadaUncheckedUpdateManyInput>
    /**
     * Filter which mensagem_privadas to update
     */
    where?: mensagem_privadaWhereInput
  }

  /**
   * mensagem_privada upsert
   */
  export type mensagem_privadaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_privada
     */
    select?: mensagem_privadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_privadaInclude<ExtArgs> | null
    /**
     * The filter to search for the mensagem_privada to update in case it exists.
     */
    where: mensagem_privadaWhereUniqueInput
    /**
     * In case the mensagem_privada found by the `where` argument doesn't exist, create a new mensagem_privada with this data.
     */
    create: XOR<mensagem_privadaCreateInput, mensagem_privadaUncheckedCreateInput>
    /**
     * In case the mensagem_privada was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mensagem_privadaUpdateInput, mensagem_privadaUncheckedUpdateInput>
  }

  /**
   * mensagem_privada delete
   */
  export type mensagem_privadaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_privada
     */
    select?: mensagem_privadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_privadaInclude<ExtArgs> | null
    /**
     * Filter which mensagem_privada to delete.
     */
    where: mensagem_privadaWhereUniqueInput
  }

  /**
   * mensagem_privada deleteMany
   */
  export type mensagem_privadaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mensagem_privadas to delete
     */
    where?: mensagem_privadaWhereInput
  }

  /**
   * mensagem_privada without action
   */
  export type mensagem_privadaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_privada
     */
    select?: mensagem_privadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_privadaInclude<ExtArgs> | null
  }


  /**
   * Model pessoa
   */

  export type AggregatePessoa = {
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  export type PessoaAvgAggregateOutputType = {
    id: number | null
  }

  export type PessoaSumAggregateOutputType = {
    id: bigint | null
  }

  export type PessoaMinAggregateOutputType = {
    id: bigint | null
    nome: string | null
    email: string | null
    senha: string | null
    cpf: string | null
    data_cadastro: Date | null
  }

  export type PessoaMaxAggregateOutputType = {
    id: bigint | null
    nome: string | null
    email: string | null
    senha: string | null
    cpf: string | null
    data_cadastro: Date | null
  }

  export type PessoaCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    senha: number
    cpf: number
    data_cadastro: number
    _all: number
  }


  export type PessoaAvgAggregateInputType = {
    id?: true
  }

  export type PessoaSumAggregateInputType = {
    id?: true
  }

  export type PessoaMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    cpf?: true
    data_cadastro?: true
  }

  export type PessoaMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    cpf?: true
    data_cadastro?: true
  }

  export type PessoaCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    cpf?: true
    data_cadastro?: true
    _all?: true
  }

  export type PessoaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pessoa to aggregate.
     */
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     */
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pessoas
    **/
    _count?: true | PessoaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PessoaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PessoaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaMaxAggregateInputType
  }

  export type GetPessoaAggregateType<T extends PessoaAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoa[P]>
      : GetScalarType<T[P], AggregatePessoa[P]>
  }




  export type pessoaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaWhereInput
    orderBy?: pessoaOrderByWithAggregationInput | pessoaOrderByWithAggregationInput[]
    by: PessoaScalarFieldEnum[] | PessoaScalarFieldEnum
    having?: pessoaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaCountAggregateInputType | true
    _avg?: PessoaAvgAggregateInputType
    _sum?: PessoaSumAggregateInputType
    _min?: PessoaMinAggregateInputType
    _max?: PessoaMaxAggregateInputType
  }

  export type PessoaGroupByOutputType = {
    id: bigint
    nome: string
    email: string
    senha: string
    cpf: string
    data_cadastro: Date
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  type GetPessoaGroupByPayload<T extends pessoaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PessoaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaGroupByOutputType[P]>
        }
      >
    >


  export type pessoaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    cpf?: boolean
    data_cadastro?: boolean
    Messages?: boolean | pessoa$MessagesArgs<ExtArgs>
    grupos_pessoas?: boolean | pessoa$grupos_pessoasArgs<ExtArgs>
    mensagem_grupo?: boolean | pessoa$mensagem_grupoArgs<ExtArgs>
    mensagem_privada?: boolean | pessoa$mensagem_privadaArgs<ExtArgs>
    _count?: boolean | PessoaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoa"]>

  export type pessoaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    cpf?: boolean
    data_cadastro?: boolean
  }, ExtArgs["result"]["pessoa"]>

  export type pessoaSelectScalar = {
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    cpf?: boolean
    data_cadastro?: boolean
  }

  export type pessoaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Messages?: boolean | pessoa$MessagesArgs<ExtArgs>
    grupos_pessoas?: boolean | pessoa$grupos_pessoasArgs<ExtArgs>
    mensagem_grupo?: boolean | pessoa$mensagem_grupoArgs<ExtArgs>
    mensagem_privada?: boolean | pessoa$mensagem_privadaArgs<ExtArgs>
    _count?: boolean | PessoaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type pessoaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $pessoaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pessoa"
    objects: {
      Messages: Prisma.$MessagesPayload<ExtArgs>[]
      grupos_pessoas: Prisma.$grupos_pessoasPayload<ExtArgs>[]
      mensagem_grupo: Prisma.$mensagem_grupoPayload<ExtArgs>[]
      mensagem_privada: Prisma.$mensagem_privadaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      nome: string
      email: string
      senha: string
      cpf: string
      data_cadastro: Date
    }, ExtArgs["result"]["pessoa"]>
    composites: {}
  }

  type pessoaGetPayload<S extends boolean | null | undefined | pessoaDefaultArgs> = $Result.GetResult<Prisma.$pessoaPayload, S>

  type pessoaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pessoaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PessoaCountAggregateInputType | true
    }

  export interface pessoaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pessoa'], meta: { name: 'pessoa' } }
    /**
     * Find zero or one Pessoa that matches the filter.
     * @param {pessoaFindUniqueArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pessoaFindUniqueArgs>(args: SelectSubset<T, pessoaFindUniqueArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pessoa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pessoaFindUniqueOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pessoaFindUniqueOrThrowArgs>(args: SelectSubset<T, pessoaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pessoa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindFirstArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pessoaFindFirstArgs>(args?: SelectSubset<T, pessoaFindFirstArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pessoa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindFirstOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pessoaFindFirstOrThrowArgs>(args?: SelectSubset<T, pessoaFindFirstOrThrowArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pessoas
     * const pessoas = await prisma.pessoa.findMany()
     * 
     * // Get first 10 Pessoas
     * const pessoas = await prisma.pessoa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pessoaWithIdOnly = await prisma.pessoa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pessoaFindManyArgs>(args?: SelectSubset<T, pessoaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pessoa.
     * @param {pessoaCreateArgs} args - Arguments to create a Pessoa.
     * @example
     * // Create one Pessoa
     * const Pessoa = await prisma.pessoa.create({
     *   data: {
     *     // ... data to create a Pessoa
     *   }
     * })
     * 
     */
    create<T extends pessoaCreateArgs>(args: SelectSubset<T, pessoaCreateArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pessoas.
     * @param {pessoaCreateManyArgs} args - Arguments to create many Pessoas.
     * @example
     * // Create many Pessoas
     * const pessoa = await prisma.pessoa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pessoaCreateManyArgs>(args?: SelectSubset<T, pessoaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pessoas and returns the data saved in the database.
     * @param {pessoaCreateManyAndReturnArgs} args - Arguments to create many Pessoas.
     * @example
     * // Create many Pessoas
     * const pessoa = await prisma.pessoa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pessoas and only return the `id`
     * const pessoaWithIdOnly = await prisma.pessoa.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pessoaCreateManyAndReturnArgs>(args?: SelectSubset<T, pessoaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pessoa.
     * @param {pessoaDeleteArgs} args - Arguments to delete one Pessoa.
     * @example
     * // Delete one Pessoa
     * const Pessoa = await prisma.pessoa.delete({
     *   where: {
     *     // ... filter to delete one Pessoa
     *   }
     * })
     * 
     */
    delete<T extends pessoaDeleteArgs>(args: SelectSubset<T, pessoaDeleteArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pessoa.
     * @param {pessoaUpdateArgs} args - Arguments to update one Pessoa.
     * @example
     * // Update one Pessoa
     * const pessoa = await prisma.pessoa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pessoaUpdateArgs>(args: SelectSubset<T, pessoaUpdateArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pessoas.
     * @param {pessoaDeleteManyArgs} args - Arguments to filter Pessoas to delete.
     * @example
     * // Delete a few Pessoas
     * const { count } = await prisma.pessoa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pessoaDeleteManyArgs>(args?: SelectSubset<T, pessoaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pessoas
     * const pessoa = await prisma.pessoa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pessoaUpdateManyArgs>(args: SelectSubset<T, pessoaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pessoa.
     * @param {pessoaUpsertArgs} args - Arguments to update or create a Pessoa.
     * @example
     * // Update or create a Pessoa
     * const pessoa = await prisma.pessoa.upsert({
     *   create: {
     *     // ... data to create a Pessoa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pessoa we want to update
     *   }
     * })
     */
    upsert<T extends pessoaUpsertArgs>(args: SelectSubset<T, pessoaUpsertArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCountArgs} args - Arguments to filter Pessoas to count.
     * @example
     * // Count the number of Pessoas
     * const count = await prisma.pessoa.count({
     *   where: {
     *     // ... the filter for the Pessoas we want to count
     *   }
     * })
    **/
    count<T extends pessoaCountArgs>(
      args?: Subset<T, pessoaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaAggregateArgs>(args: Subset<T, PessoaAggregateArgs>): Prisma.PrismaPromise<GetPessoaAggregateType<T>>

    /**
     * Group by Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pessoaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pessoaGroupByArgs['orderBy'] }
        : { orderBy?: pessoaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pessoaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pessoa model
   */
  readonly fields: pessoaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pessoa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pessoaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Messages<T extends pessoa$MessagesArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$MessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findMany"> | Null>
    grupos_pessoas<T extends pessoa$grupos_pessoasArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$grupos_pessoasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grupos_pessoasPayload<ExtArgs>, T, "findMany"> | Null>
    mensagem_grupo<T extends pessoa$mensagem_grupoArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$mensagem_grupoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mensagem_grupoPayload<ExtArgs>, T, "findMany"> | Null>
    mensagem_privada<T extends pessoa$mensagem_privadaArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$mensagem_privadaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mensagem_privadaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pessoa model
   */ 
  interface pessoaFieldRefs {
    readonly id: FieldRef<"pessoa", 'BigInt'>
    readonly nome: FieldRef<"pessoa", 'String'>
    readonly email: FieldRef<"pessoa", 'String'>
    readonly senha: FieldRef<"pessoa", 'String'>
    readonly cpf: FieldRef<"pessoa", 'String'>
    readonly data_cadastro: FieldRef<"pessoa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pessoa findUnique
   */
  export type pessoaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoa to fetch.
     */
    where: pessoaWhereUniqueInput
  }

  /**
   * pessoa findUniqueOrThrow
   */
  export type pessoaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoa to fetch.
     */
    where: pessoaWhereUniqueInput
  }

  /**
   * pessoa findFirst
   */
  export type pessoaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoa to fetch.
     */
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     */
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoas.
     */
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoas.
     */
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * pessoa findFirstOrThrow
   */
  export type pessoaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoa to fetch.
     */
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     */
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoas.
     */
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoas.
     */
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * pessoa findMany
   */
  export type pessoaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoas to fetch.
     */
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     */
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pessoas.
     */
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     */
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * pessoa create
   */
  export type pessoaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * The data needed to create a pessoa.
     */
    data: XOR<pessoaCreateInput, pessoaUncheckedCreateInput>
  }

  /**
   * pessoa createMany
   */
  export type pessoaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pessoas.
     */
    data: pessoaCreateManyInput | pessoaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pessoa createManyAndReturn
   */
  export type pessoaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many pessoas.
     */
    data: pessoaCreateManyInput | pessoaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pessoa update
   */
  export type pessoaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * The data needed to update a pessoa.
     */
    data: XOR<pessoaUpdateInput, pessoaUncheckedUpdateInput>
    /**
     * Choose, which pessoa to update.
     */
    where: pessoaWhereUniqueInput
  }

  /**
   * pessoa updateMany
   */
  export type pessoaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pessoas.
     */
    data: XOR<pessoaUpdateManyMutationInput, pessoaUncheckedUpdateManyInput>
    /**
     * Filter which pessoas to update
     */
    where?: pessoaWhereInput
  }

  /**
   * pessoa upsert
   */
  export type pessoaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * The filter to search for the pessoa to update in case it exists.
     */
    where: pessoaWhereUniqueInput
    /**
     * In case the pessoa found by the `where` argument doesn't exist, create a new pessoa with this data.
     */
    create: XOR<pessoaCreateInput, pessoaUncheckedCreateInput>
    /**
     * In case the pessoa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pessoaUpdateInput, pessoaUncheckedUpdateInput>
  }

  /**
   * pessoa delete
   */
  export type pessoaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter which pessoa to delete.
     */
    where: pessoaWhereUniqueInput
  }

  /**
   * pessoa deleteMany
   */
  export type pessoaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pessoas to delete
     */
    where?: pessoaWhereInput
  }

  /**
   * pessoa.Messages
   */
  export type pessoa$MessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    where?: MessagesWhereInput
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    cursor?: MessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * pessoa.grupos_pessoas
   */
  export type pessoa$grupos_pessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grupos_pessoas
     */
    select?: grupos_pessoasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grupos_pessoasInclude<ExtArgs> | null
    where?: grupos_pessoasWhereInput
    orderBy?: grupos_pessoasOrderByWithRelationInput | grupos_pessoasOrderByWithRelationInput[]
    cursor?: grupos_pessoasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Grupos_pessoasScalarFieldEnum | Grupos_pessoasScalarFieldEnum[]
  }

  /**
   * pessoa.mensagem_grupo
   */
  export type pessoa$mensagem_grupoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_grupo
     */
    select?: mensagem_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_grupoInclude<ExtArgs> | null
    where?: mensagem_grupoWhereInput
    orderBy?: mensagem_grupoOrderByWithRelationInput | mensagem_grupoOrderByWithRelationInput[]
    cursor?: mensagem_grupoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Mensagem_grupoScalarFieldEnum | Mensagem_grupoScalarFieldEnum[]
  }

  /**
   * pessoa.mensagem_privada
   */
  export type pessoa$mensagem_privadaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mensagem_privada
     */
    select?: mensagem_privadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mensagem_privadaInclude<ExtArgs> | null
    where?: mensagem_privadaWhereInput
    orderBy?: mensagem_privadaOrderByWithRelationInput | mensagem_privadaOrderByWithRelationInput[]
    cursor?: mensagem_privadaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Mensagem_privadaScalarFieldEnum | Mensagem_privadaScalarFieldEnum[]
  }

  /**
   * pessoa without action
   */
  export type pessoaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const MessagesScalarFieldEnum: {
    id: 'id',
    id_receptor: 'id_receptor',
    data_cadastro: 'data_cadastro',
    id_pessoa: 'id_pessoa',
    id_grupo: 'id_grupo'
  };

  export type MessagesScalarFieldEnum = (typeof MessagesScalarFieldEnum)[keyof typeof MessagesScalarFieldEnum]


  export const GrupoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    descricao: 'descricao'
  };

  export type GrupoScalarFieldEnum = (typeof GrupoScalarFieldEnum)[keyof typeof GrupoScalarFieldEnum]


  export const Grupos_pessoasScalarFieldEnum: {
    id: 'id',
    data_cadastro: 'data_cadastro',
    id_pessoa: 'id_pessoa',
    id_grupo: 'id_grupo'
  };

  export type Grupos_pessoasScalarFieldEnum = (typeof Grupos_pessoasScalarFieldEnum)[keyof typeof Grupos_pessoasScalarFieldEnum]


  export const Mensagem_grupoScalarFieldEnum: {
    id: 'id',
    mensagem: 'mensagem',
    data_cadastro: 'data_cadastro',
    id_Messages: 'id_Messages',
    id_pessoa: 'id_pessoa'
  };

  export type Mensagem_grupoScalarFieldEnum = (typeof Mensagem_grupoScalarFieldEnum)[keyof typeof Mensagem_grupoScalarFieldEnum]


  export const Mensagem_privadaScalarFieldEnum: {
    id: 'id',
    mensagem: 'mensagem',
    data_cadastro: 'data_cadastro',
    id_Messages: 'id_Messages',
    id_pessoa: 'id_pessoa'
  };

  export type Mensagem_privadaScalarFieldEnum = (typeof Mensagem_privadaScalarFieldEnum)[keyof typeof Mensagem_privadaScalarFieldEnum]


  export const PessoaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    senha: 'senha',
    cpf: 'cpf',
    data_cadastro: 'data_cadastro'
  };

  export type PessoaScalarFieldEnum = (typeof PessoaScalarFieldEnum)[keyof typeof PessoaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type MessagesWhereInput = {
    AND?: MessagesWhereInput | MessagesWhereInput[]
    OR?: MessagesWhereInput[]
    NOT?: MessagesWhereInput | MessagesWhereInput[]
    id?: BigIntFilter<"Messages"> | bigint | number
    id_receptor?: BigIntNullableFilter<"Messages"> | bigint | number | null
    data_cadastro?: DateTimeFilter<"Messages"> | Date | string
    id_pessoa?: BigIntFilter<"Messages"> | bigint | number
    id_grupo?: BigIntNullableFilter<"Messages"> | bigint | number | null
    grupo?: XOR<GrupoNullableRelationFilter, grupoWhereInput> | null
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
    mensagem_grupo?: Mensagem_grupoListRelationFilter
    mensagem_privada?: Mensagem_privadaListRelationFilter
  }

  export type MessagesOrderByWithRelationInput = {
    id?: SortOrder
    id_receptor?: SortOrderInput | SortOrder
    data_cadastro?: SortOrder
    id_pessoa?: SortOrder
    id_grupo?: SortOrderInput | SortOrder
    grupo?: grupoOrderByWithRelationInput
    pessoa?: pessoaOrderByWithRelationInput
    mensagem_grupo?: mensagem_grupoOrderByRelationAggregateInput
    mensagem_privada?: mensagem_privadaOrderByRelationAggregateInput
  }

  export type MessagesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    id_pessoa_id_grupo?: MessagesId_pessoaId_grupoCompoundUniqueInput
    id_pessoa_id_receptor?: MessagesId_pessoaId_receptorCompoundUniqueInput
    AND?: MessagesWhereInput | MessagesWhereInput[]
    OR?: MessagesWhereInput[]
    NOT?: MessagesWhereInput | MessagesWhereInput[]
    id_receptor?: BigIntNullableFilter<"Messages"> | bigint | number | null
    data_cadastro?: DateTimeFilter<"Messages"> | Date | string
    id_pessoa?: BigIntFilter<"Messages"> | bigint | number
    id_grupo?: BigIntNullableFilter<"Messages"> | bigint | number | null
    grupo?: XOR<GrupoNullableRelationFilter, grupoWhereInput> | null
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
    mensagem_grupo?: Mensagem_grupoListRelationFilter
    mensagem_privada?: Mensagem_privadaListRelationFilter
  }, "id" | "id_pessoa_id_grupo" | "id_pessoa_id_receptor">

  export type MessagesOrderByWithAggregationInput = {
    id?: SortOrder
    id_receptor?: SortOrderInput | SortOrder
    data_cadastro?: SortOrder
    id_pessoa?: SortOrder
    id_grupo?: SortOrderInput | SortOrder
    _count?: MessagesCountOrderByAggregateInput
    _avg?: MessagesAvgOrderByAggregateInput
    _max?: MessagesMaxOrderByAggregateInput
    _min?: MessagesMinOrderByAggregateInput
    _sum?: MessagesSumOrderByAggregateInput
  }

  export type MessagesScalarWhereWithAggregatesInput = {
    AND?: MessagesScalarWhereWithAggregatesInput | MessagesScalarWhereWithAggregatesInput[]
    OR?: MessagesScalarWhereWithAggregatesInput[]
    NOT?: MessagesScalarWhereWithAggregatesInput | MessagesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Messages"> | bigint | number
    id_receptor?: BigIntNullableWithAggregatesFilter<"Messages"> | bigint | number | null
    data_cadastro?: DateTimeWithAggregatesFilter<"Messages"> | Date | string
    id_pessoa?: BigIntWithAggregatesFilter<"Messages"> | bigint | number
    id_grupo?: BigIntNullableWithAggregatesFilter<"Messages"> | bigint | number | null
  }

  export type grupoWhereInput = {
    AND?: grupoWhereInput | grupoWhereInput[]
    OR?: grupoWhereInput[]
    NOT?: grupoWhereInput | grupoWhereInput[]
    id?: BigIntFilter<"grupo"> | bigint | number
    nome?: StringFilter<"grupo"> | string
    descricao?: StringNullableFilter<"grupo"> | string | null
    Messages?: MessagesListRelationFilter
    grupos_pessoas?: Grupos_pessoasListRelationFilter
  }

  export type grupoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    Messages?: MessagesOrderByRelationAggregateInput
    grupos_pessoas?: grupos_pessoasOrderByRelationAggregateInput
  }

  export type grupoWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: grupoWhereInput | grupoWhereInput[]
    OR?: grupoWhereInput[]
    NOT?: grupoWhereInput | grupoWhereInput[]
    nome?: StringFilter<"grupo"> | string
    descricao?: StringNullableFilter<"grupo"> | string | null
    Messages?: MessagesListRelationFilter
    grupos_pessoas?: Grupos_pessoasListRelationFilter
  }, "id">

  export type grupoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    _count?: grupoCountOrderByAggregateInput
    _avg?: grupoAvgOrderByAggregateInput
    _max?: grupoMaxOrderByAggregateInput
    _min?: grupoMinOrderByAggregateInput
    _sum?: grupoSumOrderByAggregateInput
  }

  export type grupoScalarWhereWithAggregatesInput = {
    AND?: grupoScalarWhereWithAggregatesInput | grupoScalarWhereWithAggregatesInput[]
    OR?: grupoScalarWhereWithAggregatesInput[]
    NOT?: grupoScalarWhereWithAggregatesInput | grupoScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"grupo"> | bigint | number
    nome?: StringWithAggregatesFilter<"grupo"> | string
    descricao?: StringNullableWithAggregatesFilter<"grupo"> | string | null
  }

  export type grupos_pessoasWhereInput = {
    AND?: grupos_pessoasWhereInput | grupos_pessoasWhereInput[]
    OR?: grupos_pessoasWhereInput[]
    NOT?: grupos_pessoasWhereInput | grupos_pessoasWhereInput[]
    id?: BigIntFilter<"grupos_pessoas"> | bigint | number
    data_cadastro?: DateTimeFilter<"grupos_pessoas"> | Date | string
    id_pessoa?: BigIntFilter<"grupos_pessoas"> | bigint | number
    id_grupo?: BigIntFilter<"grupos_pessoas"> | bigint | number
    grupo?: XOR<GrupoRelationFilter, grupoWhereInput>
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
  }

  export type grupos_pessoasOrderByWithRelationInput = {
    id?: SortOrder
    data_cadastro?: SortOrder
    id_pessoa?: SortOrder
    id_grupo?: SortOrder
    grupo?: grupoOrderByWithRelationInput
    pessoa?: pessoaOrderByWithRelationInput
  }

  export type grupos_pessoasWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    id_pessoa_id_grupo?: grupos_pessoasId_pessoaId_grupoCompoundUniqueInput
    AND?: grupos_pessoasWhereInput | grupos_pessoasWhereInput[]
    OR?: grupos_pessoasWhereInput[]
    NOT?: grupos_pessoasWhereInput | grupos_pessoasWhereInput[]
    data_cadastro?: DateTimeFilter<"grupos_pessoas"> | Date | string
    id_pessoa?: BigIntFilter<"grupos_pessoas"> | bigint | number
    id_grupo?: BigIntFilter<"grupos_pessoas"> | bigint | number
    grupo?: XOR<GrupoRelationFilter, grupoWhereInput>
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
  }, "id" | "id_pessoa_id_grupo">

  export type grupos_pessoasOrderByWithAggregationInput = {
    id?: SortOrder
    data_cadastro?: SortOrder
    id_pessoa?: SortOrder
    id_grupo?: SortOrder
    _count?: grupos_pessoasCountOrderByAggregateInput
    _avg?: grupos_pessoasAvgOrderByAggregateInput
    _max?: grupos_pessoasMaxOrderByAggregateInput
    _min?: grupos_pessoasMinOrderByAggregateInput
    _sum?: grupos_pessoasSumOrderByAggregateInput
  }

  export type grupos_pessoasScalarWhereWithAggregatesInput = {
    AND?: grupos_pessoasScalarWhereWithAggregatesInput | grupos_pessoasScalarWhereWithAggregatesInput[]
    OR?: grupos_pessoasScalarWhereWithAggregatesInput[]
    NOT?: grupos_pessoasScalarWhereWithAggregatesInput | grupos_pessoasScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"grupos_pessoas"> | bigint | number
    data_cadastro?: DateTimeWithAggregatesFilter<"grupos_pessoas"> | Date | string
    id_pessoa?: BigIntWithAggregatesFilter<"grupos_pessoas"> | bigint | number
    id_grupo?: BigIntWithAggregatesFilter<"grupos_pessoas"> | bigint | number
  }

  export type mensagem_grupoWhereInput = {
    AND?: mensagem_grupoWhereInput | mensagem_grupoWhereInput[]
    OR?: mensagem_grupoWhereInput[]
    NOT?: mensagem_grupoWhereInput | mensagem_grupoWhereInput[]
    id?: BigIntFilter<"mensagem_grupo"> | bigint | number
    mensagem?: StringFilter<"mensagem_grupo"> | string
    data_cadastro?: DateTimeFilter<"mensagem_grupo"> | Date | string
    id_Messages?: BigIntFilter<"mensagem_grupo"> | bigint | number
    id_pessoa?: BigIntFilter<"mensagem_grupo"> | bigint | number
    Messages?: XOR<MessagesRelationFilter, MessagesWhereInput>
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
  }

  export type mensagem_grupoOrderByWithRelationInput = {
    id?: SortOrder
    mensagem?: SortOrder
    data_cadastro?: SortOrder
    id_Messages?: SortOrder
    id_pessoa?: SortOrder
    Messages?: MessagesOrderByWithRelationInput
    pessoa?: pessoaOrderByWithRelationInput
  }

  export type mensagem_grupoWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: mensagem_grupoWhereInput | mensagem_grupoWhereInput[]
    OR?: mensagem_grupoWhereInput[]
    NOT?: mensagem_grupoWhereInput | mensagem_grupoWhereInput[]
    mensagem?: StringFilter<"mensagem_grupo"> | string
    data_cadastro?: DateTimeFilter<"mensagem_grupo"> | Date | string
    id_Messages?: BigIntFilter<"mensagem_grupo"> | bigint | number
    id_pessoa?: BigIntFilter<"mensagem_grupo"> | bigint | number
    Messages?: XOR<MessagesRelationFilter, MessagesWhereInput>
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
  }, "id">

  export type mensagem_grupoOrderByWithAggregationInput = {
    id?: SortOrder
    mensagem?: SortOrder
    data_cadastro?: SortOrder
    id_Messages?: SortOrder
    id_pessoa?: SortOrder
    _count?: mensagem_grupoCountOrderByAggregateInput
    _avg?: mensagem_grupoAvgOrderByAggregateInput
    _max?: mensagem_grupoMaxOrderByAggregateInput
    _min?: mensagem_grupoMinOrderByAggregateInput
    _sum?: mensagem_grupoSumOrderByAggregateInput
  }

  export type mensagem_grupoScalarWhereWithAggregatesInput = {
    AND?: mensagem_grupoScalarWhereWithAggregatesInput | mensagem_grupoScalarWhereWithAggregatesInput[]
    OR?: mensagem_grupoScalarWhereWithAggregatesInput[]
    NOT?: mensagem_grupoScalarWhereWithAggregatesInput | mensagem_grupoScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"mensagem_grupo"> | bigint | number
    mensagem?: StringWithAggregatesFilter<"mensagem_grupo"> | string
    data_cadastro?: DateTimeWithAggregatesFilter<"mensagem_grupo"> | Date | string
    id_Messages?: BigIntWithAggregatesFilter<"mensagem_grupo"> | bigint | number
    id_pessoa?: BigIntWithAggregatesFilter<"mensagem_grupo"> | bigint | number
  }

  export type mensagem_privadaWhereInput = {
    AND?: mensagem_privadaWhereInput | mensagem_privadaWhereInput[]
    OR?: mensagem_privadaWhereInput[]
    NOT?: mensagem_privadaWhereInput | mensagem_privadaWhereInput[]
    id?: BigIntFilter<"mensagem_privada"> | bigint | number
    mensagem?: StringFilter<"mensagem_privada"> | string
    data_cadastro?: DateTimeFilter<"mensagem_privada"> | Date | string
    id_Messages?: BigIntFilter<"mensagem_privada"> | bigint | number
    id_pessoa?: BigIntFilter<"mensagem_privada"> | bigint | number
    Messages?: XOR<MessagesRelationFilter, MessagesWhereInput>
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
  }

  export type mensagem_privadaOrderByWithRelationInput = {
    id?: SortOrder
    mensagem?: SortOrder
    data_cadastro?: SortOrder
    id_Messages?: SortOrder
    id_pessoa?: SortOrder
    Messages?: MessagesOrderByWithRelationInput
    pessoa?: pessoaOrderByWithRelationInput
  }

  export type mensagem_privadaWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: mensagem_privadaWhereInput | mensagem_privadaWhereInput[]
    OR?: mensagem_privadaWhereInput[]
    NOT?: mensagem_privadaWhereInput | mensagem_privadaWhereInput[]
    mensagem?: StringFilter<"mensagem_privada"> | string
    data_cadastro?: DateTimeFilter<"mensagem_privada"> | Date | string
    id_Messages?: BigIntFilter<"mensagem_privada"> | bigint | number
    id_pessoa?: BigIntFilter<"mensagem_privada"> | bigint | number
    Messages?: XOR<MessagesRelationFilter, MessagesWhereInput>
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
  }, "id">

  export type mensagem_privadaOrderByWithAggregationInput = {
    id?: SortOrder
    mensagem?: SortOrder
    data_cadastro?: SortOrder
    id_Messages?: SortOrder
    id_pessoa?: SortOrder
    _count?: mensagem_privadaCountOrderByAggregateInput
    _avg?: mensagem_privadaAvgOrderByAggregateInput
    _max?: mensagem_privadaMaxOrderByAggregateInput
    _min?: mensagem_privadaMinOrderByAggregateInput
    _sum?: mensagem_privadaSumOrderByAggregateInput
  }

  export type mensagem_privadaScalarWhereWithAggregatesInput = {
    AND?: mensagem_privadaScalarWhereWithAggregatesInput | mensagem_privadaScalarWhereWithAggregatesInput[]
    OR?: mensagem_privadaScalarWhereWithAggregatesInput[]
    NOT?: mensagem_privadaScalarWhereWithAggregatesInput | mensagem_privadaScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"mensagem_privada"> | bigint | number
    mensagem?: StringWithAggregatesFilter<"mensagem_privada"> | string
    data_cadastro?: DateTimeWithAggregatesFilter<"mensagem_privada"> | Date | string
    id_Messages?: BigIntWithAggregatesFilter<"mensagem_privada"> | bigint | number
    id_pessoa?: BigIntWithAggregatesFilter<"mensagem_privada"> | bigint | number
  }

  export type pessoaWhereInput = {
    AND?: pessoaWhereInput | pessoaWhereInput[]
    OR?: pessoaWhereInput[]
    NOT?: pessoaWhereInput | pessoaWhereInput[]
    id?: BigIntFilter<"pessoa"> | bigint | number
    nome?: StringFilter<"pessoa"> | string
    email?: StringFilter<"pessoa"> | string
    senha?: StringFilter<"pessoa"> | string
    cpf?: StringFilter<"pessoa"> | string
    data_cadastro?: DateTimeFilter<"pessoa"> | Date | string
    Messages?: MessagesListRelationFilter
    grupos_pessoas?: Grupos_pessoasListRelationFilter
    mensagem_grupo?: Mensagem_grupoListRelationFilter
    mensagem_privada?: Mensagem_privadaListRelationFilter
  }

  export type pessoaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    cpf?: SortOrder
    data_cadastro?: SortOrder
    Messages?: MessagesOrderByRelationAggregateInput
    grupos_pessoas?: grupos_pessoasOrderByRelationAggregateInput
    mensagem_grupo?: mensagem_grupoOrderByRelationAggregateInput
    mensagem_privada?: mensagem_privadaOrderByRelationAggregateInput
  }

  export type pessoaWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    cpf?: string
    AND?: pessoaWhereInput | pessoaWhereInput[]
    OR?: pessoaWhereInput[]
    NOT?: pessoaWhereInput | pessoaWhereInput[]
    nome?: StringFilter<"pessoa"> | string
    senha?: StringFilter<"pessoa"> | string
    data_cadastro?: DateTimeFilter<"pessoa"> | Date | string
    Messages?: MessagesListRelationFilter
    grupos_pessoas?: Grupos_pessoasListRelationFilter
    mensagem_grupo?: Mensagem_grupoListRelationFilter
    mensagem_privada?: Mensagem_privadaListRelationFilter
  }, "id" | "email" | "cpf">

  export type pessoaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    cpf?: SortOrder
    data_cadastro?: SortOrder
    _count?: pessoaCountOrderByAggregateInput
    _avg?: pessoaAvgOrderByAggregateInput
    _max?: pessoaMaxOrderByAggregateInput
    _min?: pessoaMinOrderByAggregateInput
    _sum?: pessoaSumOrderByAggregateInput
  }

  export type pessoaScalarWhereWithAggregatesInput = {
    AND?: pessoaScalarWhereWithAggregatesInput | pessoaScalarWhereWithAggregatesInput[]
    OR?: pessoaScalarWhereWithAggregatesInput[]
    NOT?: pessoaScalarWhereWithAggregatesInput | pessoaScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"pessoa"> | bigint | number
    nome?: StringWithAggregatesFilter<"pessoa"> | string
    email?: StringWithAggregatesFilter<"pessoa"> | string
    senha?: StringWithAggregatesFilter<"pessoa"> | string
    cpf?: StringWithAggregatesFilter<"pessoa"> | string
    data_cadastro?: DateTimeWithAggregatesFilter<"pessoa"> | Date | string
  }

  export type MessagesCreateInput = {
    id?: bigint | number
    id_receptor?: bigint | number | null
    data_cadastro?: Date | string
    grupo?: grupoCreateNestedOneWithoutMessagesInput
    pessoa: pessoaCreateNestedOneWithoutMessagesInput
    mensagem_grupo?: mensagem_grupoCreateNestedManyWithoutMessagesInput
    mensagem_privada?: mensagem_privadaCreateNestedManyWithoutMessagesInput
  }

  export type MessagesUncheckedCreateInput = {
    id?: bigint | number
    id_receptor?: bigint | number | null
    data_cadastro?: Date | string
    id_pessoa: bigint | number
    id_grupo?: bigint | number | null
    mensagem_grupo?: mensagem_grupoUncheckedCreateNestedManyWithoutMessagesInput
    mensagem_privada?: mensagem_privadaUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type MessagesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    id_receptor?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    grupo?: grupoUpdateOneWithoutMessagesNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutMessagesNestedInput
    mensagem_grupo?: mensagem_grupoUpdateManyWithoutMessagesNestedInput
    mensagem_privada?: mensagem_privadaUpdateManyWithoutMessagesNestedInput
  }

  export type MessagesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    id_receptor?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
    id_grupo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mensagem_grupo?: mensagem_grupoUncheckedUpdateManyWithoutMessagesNestedInput
    mensagem_privada?: mensagem_privadaUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type MessagesCreateManyInput = {
    id?: bigint | number
    id_receptor?: bigint | number | null
    data_cadastro?: Date | string
    id_pessoa: bigint | number
    id_grupo?: bigint | number | null
  }

  export type MessagesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    id_receptor?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessagesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    id_receptor?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
    id_grupo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type grupoCreateInput = {
    id?: bigint | number
    nome?: string
    descricao?: string | null
    Messages?: MessagesCreateNestedManyWithoutGrupoInput
    grupos_pessoas?: grupos_pessoasCreateNestedManyWithoutGrupoInput
  }

  export type grupoUncheckedCreateInput = {
    id?: bigint | number
    nome?: string
    descricao?: string | null
    Messages?: MessagesUncheckedCreateNestedManyWithoutGrupoInput
    grupos_pessoas?: grupos_pessoasUncheckedCreateNestedManyWithoutGrupoInput
  }

  export type grupoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    Messages?: MessagesUpdateManyWithoutGrupoNestedInput
    grupos_pessoas?: grupos_pessoasUpdateManyWithoutGrupoNestedInput
  }

  export type grupoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    Messages?: MessagesUncheckedUpdateManyWithoutGrupoNestedInput
    grupos_pessoas?: grupos_pessoasUncheckedUpdateManyWithoutGrupoNestedInput
  }

  export type grupoCreateManyInput = {
    id?: bigint | number
    nome?: string
    descricao?: string | null
  }

  export type grupoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type grupoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type grupos_pessoasCreateInput = {
    id?: bigint | number
    data_cadastro?: Date | string
    grupo: grupoCreateNestedOneWithoutGrupos_pessoasInput
    pessoa: pessoaCreateNestedOneWithoutGrupos_pessoasInput
  }

  export type grupos_pessoasUncheckedCreateInput = {
    id?: bigint | number
    data_cadastro?: Date | string
    id_pessoa: bigint | number
    id_grupo: bigint | number
  }

  export type grupos_pessoasUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    grupo?: grupoUpdateOneRequiredWithoutGrupos_pessoasNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutGrupos_pessoasNestedInput
  }

  export type grupos_pessoasUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
    id_grupo?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type grupos_pessoasCreateManyInput = {
    id?: bigint | number
    data_cadastro?: Date | string
    id_pessoa: bigint | number
    id_grupo: bigint | number
  }

  export type grupos_pessoasUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type grupos_pessoasUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
    id_grupo?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type mensagem_grupoCreateInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    Messages: MessagesCreateNestedOneWithoutMensagem_grupoInput
    pessoa: pessoaCreateNestedOneWithoutMensagem_grupoInput
  }

  export type mensagem_grupoUncheckedCreateInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    id_Messages: bigint | number
    id_pessoa: bigint | number
  }

  export type mensagem_grupoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    Messages?: MessagesUpdateOneRequiredWithoutMensagem_grupoNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutMensagem_grupoNestedInput
  }

  export type mensagem_grupoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_Messages?: BigIntFieldUpdateOperationsInput | bigint | number
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type mensagem_grupoCreateManyInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    id_Messages: bigint | number
    id_pessoa: bigint | number
  }

  export type mensagem_grupoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mensagem_grupoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_Messages?: BigIntFieldUpdateOperationsInput | bigint | number
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type mensagem_privadaCreateInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    Messages: MessagesCreateNestedOneWithoutMensagem_privadaInput
    pessoa: pessoaCreateNestedOneWithoutMensagem_privadaInput
  }

  export type mensagem_privadaUncheckedCreateInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    id_Messages: bigint | number
    id_pessoa: bigint | number
  }

  export type mensagem_privadaUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    Messages?: MessagesUpdateOneRequiredWithoutMensagem_privadaNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutMensagem_privadaNestedInput
  }

  export type mensagem_privadaUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_Messages?: BigIntFieldUpdateOperationsInput | bigint | number
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type mensagem_privadaCreateManyInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    id_Messages: bigint | number
    id_pessoa: bigint | number
  }

  export type mensagem_privadaUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mensagem_privadaUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_Messages?: BigIntFieldUpdateOperationsInput | bigint | number
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type pessoaCreateInput = {
    id?: bigint | number
    nome?: string
    email?: string
    senha: string
    cpf?: string
    data_cadastro?: Date | string
    Messages?: MessagesCreateNestedManyWithoutPessoaInput
    grupos_pessoas?: grupos_pessoasCreateNestedManyWithoutPessoaInput
    mensagem_grupo?: mensagem_grupoCreateNestedManyWithoutPessoaInput
    mensagem_privada?: mensagem_privadaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateInput = {
    id?: bigint | number
    nome?: string
    email?: string
    senha: string
    cpf?: string
    data_cadastro?: Date | string
    Messages?: MessagesUncheckedCreateNestedManyWithoutPessoaInput
    grupos_pessoas?: grupos_pessoasUncheckedCreateNestedManyWithoutPessoaInput
    mensagem_grupo?: mensagem_grupoUncheckedCreateNestedManyWithoutPessoaInput
    mensagem_privada?: mensagem_privadaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    Messages?: MessagesUpdateManyWithoutPessoaNestedInput
    grupos_pessoas?: grupos_pessoasUpdateManyWithoutPessoaNestedInput
    mensagem_grupo?: mensagem_grupoUpdateManyWithoutPessoaNestedInput
    mensagem_privada?: mensagem_privadaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    Messages?: MessagesUncheckedUpdateManyWithoutPessoaNestedInput
    grupos_pessoas?: grupos_pessoasUncheckedUpdateManyWithoutPessoaNestedInput
    mensagem_grupo?: mensagem_grupoUncheckedUpdateManyWithoutPessoaNestedInput
    mensagem_privada?: mensagem_privadaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaCreateManyInput = {
    id?: bigint | number
    nome?: string
    email?: string
    senha: string
    cpf?: string
    data_cadastro?: Date | string
  }

  export type pessoaUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pessoaUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type GrupoNullableRelationFilter = {
    is?: grupoWhereInput | null
    isNot?: grupoWhereInput | null
  }

  export type PessoaRelationFilter = {
    is?: pessoaWhereInput
    isNot?: pessoaWhereInput
  }

  export type Mensagem_grupoListRelationFilter = {
    every?: mensagem_grupoWhereInput
    some?: mensagem_grupoWhereInput
    none?: mensagem_grupoWhereInput
  }

  export type Mensagem_privadaListRelationFilter = {
    every?: mensagem_privadaWhereInput
    some?: mensagem_privadaWhereInput
    none?: mensagem_privadaWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type mensagem_grupoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mensagem_privadaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessagesId_pessoaId_grupoCompoundUniqueInput = {
    id_pessoa: bigint | number
    id_grupo: bigint | number
  }

  export type MessagesId_pessoaId_receptorCompoundUniqueInput = {
    id_pessoa: bigint | number
    id_receptor: bigint | number
  }

  export type MessagesCountOrderByAggregateInput = {
    id?: SortOrder
    id_receptor?: SortOrder
    data_cadastro?: SortOrder
    id_pessoa?: SortOrder
    id_grupo?: SortOrder
  }

  export type MessagesAvgOrderByAggregateInput = {
    id?: SortOrder
    id_receptor?: SortOrder
    id_pessoa?: SortOrder
    id_grupo?: SortOrder
  }

  export type MessagesMaxOrderByAggregateInput = {
    id?: SortOrder
    id_receptor?: SortOrder
    data_cadastro?: SortOrder
    id_pessoa?: SortOrder
    id_grupo?: SortOrder
  }

  export type MessagesMinOrderByAggregateInput = {
    id?: SortOrder
    id_receptor?: SortOrder
    data_cadastro?: SortOrder
    id_pessoa?: SortOrder
    id_grupo?: SortOrder
  }

  export type MessagesSumOrderByAggregateInput = {
    id?: SortOrder
    id_receptor?: SortOrder
    id_pessoa?: SortOrder
    id_grupo?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type MessagesListRelationFilter = {
    every?: MessagesWhereInput
    some?: MessagesWhereInput
    none?: MessagesWhereInput
  }

  export type Grupos_pessoasListRelationFilter = {
    every?: grupos_pessoasWhereInput
    some?: grupos_pessoasWhereInput
    none?: grupos_pessoasWhereInput
  }

  export type MessagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type grupos_pessoasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type grupoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type grupoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type grupoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type grupoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type grupoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type GrupoRelationFilter = {
    is?: grupoWhereInput
    isNot?: grupoWhereInput
  }

  export type grupos_pessoasId_pessoaId_grupoCompoundUniqueInput = {
    id_pessoa: bigint | number
    id_grupo: bigint | number
  }

  export type grupos_pessoasCountOrderByAggregateInput = {
    id?: SortOrder
    data_cadastro?: SortOrder
    id_pessoa?: SortOrder
    id_grupo?: SortOrder
  }

  export type grupos_pessoasAvgOrderByAggregateInput = {
    id?: SortOrder
    id_pessoa?: SortOrder
    id_grupo?: SortOrder
  }

  export type grupos_pessoasMaxOrderByAggregateInput = {
    id?: SortOrder
    data_cadastro?: SortOrder
    id_pessoa?: SortOrder
    id_grupo?: SortOrder
  }

  export type grupos_pessoasMinOrderByAggregateInput = {
    id?: SortOrder
    data_cadastro?: SortOrder
    id_pessoa?: SortOrder
    id_grupo?: SortOrder
  }

  export type grupos_pessoasSumOrderByAggregateInput = {
    id?: SortOrder
    id_pessoa?: SortOrder
    id_grupo?: SortOrder
  }

  export type MessagesRelationFilter = {
    is?: MessagesWhereInput
    isNot?: MessagesWhereInput
  }

  export type mensagem_grupoCountOrderByAggregateInput = {
    id?: SortOrder
    mensagem?: SortOrder
    data_cadastro?: SortOrder
    id_Messages?: SortOrder
    id_pessoa?: SortOrder
  }

  export type mensagem_grupoAvgOrderByAggregateInput = {
    id?: SortOrder
    id_Messages?: SortOrder
    id_pessoa?: SortOrder
  }

  export type mensagem_grupoMaxOrderByAggregateInput = {
    id?: SortOrder
    mensagem?: SortOrder
    data_cadastro?: SortOrder
    id_Messages?: SortOrder
    id_pessoa?: SortOrder
  }

  export type mensagem_grupoMinOrderByAggregateInput = {
    id?: SortOrder
    mensagem?: SortOrder
    data_cadastro?: SortOrder
    id_Messages?: SortOrder
    id_pessoa?: SortOrder
  }

  export type mensagem_grupoSumOrderByAggregateInput = {
    id?: SortOrder
    id_Messages?: SortOrder
    id_pessoa?: SortOrder
  }

  export type mensagem_privadaCountOrderByAggregateInput = {
    id?: SortOrder
    mensagem?: SortOrder
    data_cadastro?: SortOrder
    id_Messages?: SortOrder
    id_pessoa?: SortOrder
  }

  export type mensagem_privadaAvgOrderByAggregateInput = {
    id?: SortOrder
    id_Messages?: SortOrder
    id_pessoa?: SortOrder
  }

  export type mensagem_privadaMaxOrderByAggregateInput = {
    id?: SortOrder
    mensagem?: SortOrder
    data_cadastro?: SortOrder
    id_Messages?: SortOrder
    id_pessoa?: SortOrder
  }

  export type mensagem_privadaMinOrderByAggregateInput = {
    id?: SortOrder
    mensagem?: SortOrder
    data_cadastro?: SortOrder
    id_Messages?: SortOrder
    id_pessoa?: SortOrder
  }

  export type mensagem_privadaSumOrderByAggregateInput = {
    id?: SortOrder
    id_Messages?: SortOrder
    id_pessoa?: SortOrder
  }

  export type pessoaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    cpf?: SortOrder
    data_cadastro?: SortOrder
  }

  export type pessoaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pessoaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    cpf?: SortOrder
    data_cadastro?: SortOrder
  }

  export type pessoaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    cpf?: SortOrder
    data_cadastro?: SortOrder
  }

  export type pessoaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type grupoCreateNestedOneWithoutMessagesInput = {
    create?: XOR<grupoCreateWithoutMessagesInput, grupoUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: grupoCreateOrConnectWithoutMessagesInput
    connect?: grupoWhereUniqueInput
  }

  export type pessoaCreateNestedOneWithoutMessagesInput = {
    create?: XOR<pessoaCreateWithoutMessagesInput, pessoaUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutMessagesInput
    connect?: pessoaWhereUniqueInput
  }

  export type mensagem_grupoCreateNestedManyWithoutMessagesInput = {
    create?: XOR<mensagem_grupoCreateWithoutMessagesInput, mensagem_grupoUncheckedCreateWithoutMessagesInput> | mensagem_grupoCreateWithoutMessagesInput[] | mensagem_grupoUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: mensagem_grupoCreateOrConnectWithoutMessagesInput | mensagem_grupoCreateOrConnectWithoutMessagesInput[]
    createMany?: mensagem_grupoCreateManyMessagesInputEnvelope
    connect?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
  }

  export type mensagem_privadaCreateNestedManyWithoutMessagesInput = {
    create?: XOR<mensagem_privadaCreateWithoutMessagesInput, mensagem_privadaUncheckedCreateWithoutMessagesInput> | mensagem_privadaCreateWithoutMessagesInput[] | mensagem_privadaUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: mensagem_privadaCreateOrConnectWithoutMessagesInput | mensagem_privadaCreateOrConnectWithoutMessagesInput[]
    createMany?: mensagem_privadaCreateManyMessagesInputEnvelope
    connect?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
  }

  export type mensagem_grupoUncheckedCreateNestedManyWithoutMessagesInput = {
    create?: XOR<mensagem_grupoCreateWithoutMessagesInput, mensagem_grupoUncheckedCreateWithoutMessagesInput> | mensagem_grupoCreateWithoutMessagesInput[] | mensagem_grupoUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: mensagem_grupoCreateOrConnectWithoutMessagesInput | mensagem_grupoCreateOrConnectWithoutMessagesInput[]
    createMany?: mensagem_grupoCreateManyMessagesInputEnvelope
    connect?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
  }

  export type mensagem_privadaUncheckedCreateNestedManyWithoutMessagesInput = {
    create?: XOR<mensagem_privadaCreateWithoutMessagesInput, mensagem_privadaUncheckedCreateWithoutMessagesInput> | mensagem_privadaCreateWithoutMessagesInput[] | mensagem_privadaUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: mensagem_privadaCreateOrConnectWithoutMessagesInput | mensagem_privadaCreateOrConnectWithoutMessagesInput[]
    createMany?: mensagem_privadaCreateManyMessagesInputEnvelope
    connect?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type grupoUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<grupoCreateWithoutMessagesInput, grupoUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: grupoCreateOrConnectWithoutMessagesInput
    upsert?: grupoUpsertWithoutMessagesInput
    disconnect?: grupoWhereInput | boolean
    delete?: grupoWhereInput | boolean
    connect?: grupoWhereUniqueInput
    update?: XOR<XOR<grupoUpdateToOneWithWhereWithoutMessagesInput, grupoUpdateWithoutMessagesInput>, grupoUncheckedUpdateWithoutMessagesInput>
  }

  export type pessoaUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<pessoaCreateWithoutMessagesInput, pessoaUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutMessagesInput
    upsert?: pessoaUpsertWithoutMessagesInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutMessagesInput, pessoaUpdateWithoutMessagesInput>, pessoaUncheckedUpdateWithoutMessagesInput>
  }

  export type mensagem_grupoUpdateManyWithoutMessagesNestedInput = {
    create?: XOR<mensagem_grupoCreateWithoutMessagesInput, mensagem_grupoUncheckedCreateWithoutMessagesInput> | mensagem_grupoCreateWithoutMessagesInput[] | mensagem_grupoUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: mensagem_grupoCreateOrConnectWithoutMessagesInput | mensagem_grupoCreateOrConnectWithoutMessagesInput[]
    upsert?: mensagem_grupoUpsertWithWhereUniqueWithoutMessagesInput | mensagem_grupoUpsertWithWhereUniqueWithoutMessagesInput[]
    createMany?: mensagem_grupoCreateManyMessagesInputEnvelope
    set?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    disconnect?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    delete?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    connect?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    update?: mensagem_grupoUpdateWithWhereUniqueWithoutMessagesInput | mensagem_grupoUpdateWithWhereUniqueWithoutMessagesInput[]
    updateMany?: mensagem_grupoUpdateManyWithWhereWithoutMessagesInput | mensagem_grupoUpdateManyWithWhereWithoutMessagesInput[]
    deleteMany?: mensagem_grupoScalarWhereInput | mensagem_grupoScalarWhereInput[]
  }

  export type mensagem_privadaUpdateManyWithoutMessagesNestedInput = {
    create?: XOR<mensagem_privadaCreateWithoutMessagesInput, mensagem_privadaUncheckedCreateWithoutMessagesInput> | mensagem_privadaCreateWithoutMessagesInput[] | mensagem_privadaUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: mensagem_privadaCreateOrConnectWithoutMessagesInput | mensagem_privadaCreateOrConnectWithoutMessagesInput[]
    upsert?: mensagem_privadaUpsertWithWhereUniqueWithoutMessagesInput | mensagem_privadaUpsertWithWhereUniqueWithoutMessagesInput[]
    createMany?: mensagem_privadaCreateManyMessagesInputEnvelope
    set?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    disconnect?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    delete?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    connect?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    update?: mensagem_privadaUpdateWithWhereUniqueWithoutMessagesInput | mensagem_privadaUpdateWithWhereUniqueWithoutMessagesInput[]
    updateMany?: mensagem_privadaUpdateManyWithWhereWithoutMessagesInput | mensagem_privadaUpdateManyWithWhereWithoutMessagesInput[]
    deleteMany?: mensagem_privadaScalarWhereInput | mensagem_privadaScalarWhereInput[]
  }

  export type mensagem_grupoUncheckedUpdateManyWithoutMessagesNestedInput = {
    create?: XOR<mensagem_grupoCreateWithoutMessagesInput, mensagem_grupoUncheckedCreateWithoutMessagesInput> | mensagem_grupoCreateWithoutMessagesInput[] | mensagem_grupoUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: mensagem_grupoCreateOrConnectWithoutMessagesInput | mensagem_grupoCreateOrConnectWithoutMessagesInput[]
    upsert?: mensagem_grupoUpsertWithWhereUniqueWithoutMessagesInput | mensagem_grupoUpsertWithWhereUniqueWithoutMessagesInput[]
    createMany?: mensagem_grupoCreateManyMessagesInputEnvelope
    set?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    disconnect?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    delete?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    connect?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    update?: mensagem_grupoUpdateWithWhereUniqueWithoutMessagesInput | mensagem_grupoUpdateWithWhereUniqueWithoutMessagesInput[]
    updateMany?: mensagem_grupoUpdateManyWithWhereWithoutMessagesInput | mensagem_grupoUpdateManyWithWhereWithoutMessagesInput[]
    deleteMany?: mensagem_grupoScalarWhereInput | mensagem_grupoScalarWhereInput[]
  }

  export type mensagem_privadaUncheckedUpdateManyWithoutMessagesNestedInput = {
    create?: XOR<mensagem_privadaCreateWithoutMessagesInput, mensagem_privadaUncheckedCreateWithoutMessagesInput> | mensagem_privadaCreateWithoutMessagesInput[] | mensagem_privadaUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: mensagem_privadaCreateOrConnectWithoutMessagesInput | mensagem_privadaCreateOrConnectWithoutMessagesInput[]
    upsert?: mensagem_privadaUpsertWithWhereUniqueWithoutMessagesInput | mensagem_privadaUpsertWithWhereUniqueWithoutMessagesInput[]
    createMany?: mensagem_privadaCreateManyMessagesInputEnvelope
    set?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    disconnect?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    delete?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    connect?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    update?: mensagem_privadaUpdateWithWhereUniqueWithoutMessagesInput | mensagem_privadaUpdateWithWhereUniqueWithoutMessagesInput[]
    updateMany?: mensagem_privadaUpdateManyWithWhereWithoutMessagesInput | mensagem_privadaUpdateManyWithWhereWithoutMessagesInput[]
    deleteMany?: mensagem_privadaScalarWhereInput | mensagem_privadaScalarWhereInput[]
  }

  export type MessagesCreateNestedManyWithoutGrupoInput = {
    create?: XOR<MessagesCreateWithoutGrupoInput, MessagesUncheckedCreateWithoutGrupoInput> | MessagesCreateWithoutGrupoInput[] | MessagesUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutGrupoInput | MessagesCreateOrConnectWithoutGrupoInput[]
    createMany?: MessagesCreateManyGrupoInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type grupos_pessoasCreateNestedManyWithoutGrupoInput = {
    create?: XOR<grupos_pessoasCreateWithoutGrupoInput, grupos_pessoasUncheckedCreateWithoutGrupoInput> | grupos_pessoasCreateWithoutGrupoInput[] | grupos_pessoasUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: grupos_pessoasCreateOrConnectWithoutGrupoInput | grupos_pessoasCreateOrConnectWithoutGrupoInput[]
    createMany?: grupos_pessoasCreateManyGrupoInputEnvelope
    connect?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
  }

  export type MessagesUncheckedCreateNestedManyWithoutGrupoInput = {
    create?: XOR<MessagesCreateWithoutGrupoInput, MessagesUncheckedCreateWithoutGrupoInput> | MessagesCreateWithoutGrupoInput[] | MessagesUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutGrupoInput | MessagesCreateOrConnectWithoutGrupoInput[]
    createMany?: MessagesCreateManyGrupoInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type grupos_pessoasUncheckedCreateNestedManyWithoutGrupoInput = {
    create?: XOR<grupos_pessoasCreateWithoutGrupoInput, grupos_pessoasUncheckedCreateWithoutGrupoInput> | grupos_pessoasCreateWithoutGrupoInput[] | grupos_pessoasUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: grupos_pessoasCreateOrConnectWithoutGrupoInput | grupos_pessoasCreateOrConnectWithoutGrupoInput[]
    createMany?: grupos_pessoasCreateManyGrupoInputEnvelope
    connect?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type MessagesUpdateManyWithoutGrupoNestedInput = {
    create?: XOR<MessagesCreateWithoutGrupoInput, MessagesUncheckedCreateWithoutGrupoInput> | MessagesCreateWithoutGrupoInput[] | MessagesUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutGrupoInput | MessagesCreateOrConnectWithoutGrupoInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutGrupoInput | MessagesUpsertWithWhereUniqueWithoutGrupoInput[]
    createMany?: MessagesCreateManyGrupoInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutGrupoInput | MessagesUpdateWithWhereUniqueWithoutGrupoInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutGrupoInput | MessagesUpdateManyWithWhereWithoutGrupoInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type grupos_pessoasUpdateManyWithoutGrupoNestedInput = {
    create?: XOR<grupos_pessoasCreateWithoutGrupoInput, grupos_pessoasUncheckedCreateWithoutGrupoInput> | grupos_pessoasCreateWithoutGrupoInput[] | grupos_pessoasUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: grupos_pessoasCreateOrConnectWithoutGrupoInput | grupos_pessoasCreateOrConnectWithoutGrupoInput[]
    upsert?: grupos_pessoasUpsertWithWhereUniqueWithoutGrupoInput | grupos_pessoasUpsertWithWhereUniqueWithoutGrupoInput[]
    createMany?: grupos_pessoasCreateManyGrupoInputEnvelope
    set?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    disconnect?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    delete?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    connect?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    update?: grupos_pessoasUpdateWithWhereUniqueWithoutGrupoInput | grupos_pessoasUpdateWithWhereUniqueWithoutGrupoInput[]
    updateMany?: grupos_pessoasUpdateManyWithWhereWithoutGrupoInput | grupos_pessoasUpdateManyWithWhereWithoutGrupoInput[]
    deleteMany?: grupos_pessoasScalarWhereInput | grupos_pessoasScalarWhereInput[]
  }

  export type MessagesUncheckedUpdateManyWithoutGrupoNestedInput = {
    create?: XOR<MessagesCreateWithoutGrupoInput, MessagesUncheckedCreateWithoutGrupoInput> | MessagesCreateWithoutGrupoInput[] | MessagesUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutGrupoInput | MessagesCreateOrConnectWithoutGrupoInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutGrupoInput | MessagesUpsertWithWhereUniqueWithoutGrupoInput[]
    createMany?: MessagesCreateManyGrupoInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutGrupoInput | MessagesUpdateWithWhereUniqueWithoutGrupoInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutGrupoInput | MessagesUpdateManyWithWhereWithoutGrupoInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type grupos_pessoasUncheckedUpdateManyWithoutGrupoNestedInput = {
    create?: XOR<grupos_pessoasCreateWithoutGrupoInput, grupos_pessoasUncheckedCreateWithoutGrupoInput> | grupos_pessoasCreateWithoutGrupoInput[] | grupos_pessoasUncheckedCreateWithoutGrupoInput[]
    connectOrCreate?: grupos_pessoasCreateOrConnectWithoutGrupoInput | grupos_pessoasCreateOrConnectWithoutGrupoInput[]
    upsert?: grupos_pessoasUpsertWithWhereUniqueWithoutGrupoInput | grupos_pessoasUpsertWithWhereUniqueWithoutGrupoInput[]
    createMany?: grupos_pessoasCreateManyGrupoInputEnvelope
    set?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    disconnect?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    delete?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    connect?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    update?: grupos_pessoasUpdateWithWhereUniqueWithoutGrupoInput | grupos_pessoasUpdateWithWhereUniqueWithoutGrupoInput[]
    updateMany?: grupos_pessoasUpdateManyWithWhereWithoutGrupoInput | grupos_pessoasUpdateManyWithWhereWithoutGrupoInput[]
    deleteMany?: grupos_pessoasScalarWhereInput | grupos_pessoasScalarWhereInput[]
  }

  export type grupoCreateNestedOneWithoutGrupos_pessoasInput = {
    create?: XOR<grupoCreateWithoutGrupos_pessoasInput, grupoUncheckedCreateWithoutGrupos_pessoasInput>
    connectOrCreate?: grupoCreateOrConnectWithoutGrupos_pessoasInput
    connect?: grupoWhereUniqueInput
  }

  export type pessoaCreateNestedOneWithoutGrupos_pessoasInput = {
    create?: XOR<pessoaCreateWithoutGrupos_pessoasInput, pessoaUncheckedCreateWithoutGrupos_pessoasInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutGrupos_pessoasInput
    connect?: pessoaWhereUniqueInput
  }

  export type grupoUpdateOneRequiredWithoutGrupos_pessoasNestedInput = {
    create?: XOR<grupoCreateWithoutGrupos_pessoasInput, grupoUncheckedCreateWithoutGrupos_pessoasInput>
    connectOrCreate?: grupoCreateOrConnectWithoutGrupos_pessoasInput
    upsert?: grupoUpsertWithoutGrupos_pessoasInput
    connect?: grupoWhereUniqueInput
    update?: XOR<XOR<grupoUpdateToOneWithWhereWithoutGrupos_pessoasInput, grupoUpdateWithoutGrupos_pessoasInput>, grupoUncheckedUpdateWithoutGrupos_pessoasInput>
  }

  export type pessoaUpdateOneRequiredWithoutGrupos_pessoasNestedInput = {
    create?: XOR<pessoaCreateWithoutGrupos_pessoasInput, pessoaUncheckedCreateWithoutGrupos_pessoasInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutGrupos_pessoasInput
    upsert?: pessoaUpsertWithoutGrupos_pessoasInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutGrupos_pessoasInput, pessoaUpdateWithoutGrupos_pessoasInput>, pessoaUncheckedUpdateWithoutGrupos_pessoasInput>
  }

  export type MessagesCreateNestedOneWithoutMensagem_grupoInput = {
    create?: XOR<MessagesCreateWithoutMensagem_grupoInput, MessagesUncheckedCreateWithoutMensagem_grupoInput>
    connectOrCreate?: MessagesCreateOrConnectWithoutMensagem_grupoInput
    connect?: MessagesWhereUniqueInput
  }

  export type pessoaCreateNestedOneWithoutMensagem_grupoInput = {
    create?: XOR<pessoaCreateWithoutMensagem_grupoInput, pessoaUncheckedCreateWithoutMensagem_grupoInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutMensagem_grupoInput
    connect?: pessoaWhereUniqueInput
  }

  export type MessagesUpdateOneRequiredWithoutMensagem_grupoNestedInput = {
    create?: XOR<MessagesCreateWithoutMensagem_grupoInput, MessagesUncheckedCreateWithoutMensagem_grupoInput>
    connectOrCreate?: MessagesCreateOrConnectWithoutMensagem_grupoInput
    upsert?: MessagesUpsertWithoutMensagem_grupoInput
    connect?: MessagesWhereUniqueInput
    update?: XOR<XOR<MessagesUpdateToOneWithWhereWithoutMensagem_grupoInput, MessagesUpdateWithoutMensagem_grupoInput>, MessagesUncheckedUpdateWithoutMensagem_grupoInput>
  }

  export type pessoaUpdateOneRequiredWithoutMensagem_grupoNestedInput = {
    create?: XOR<pessoaCreateWithoutMensagem_grupoInput, pessoaUncheckedCreateWithoutMensagem_grupoInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutMensagem_grupoInput
    upsert?: pessoaUpsertWithoutMensagem_grupoInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutMensagem_grupoInput, pessoaUpdateWithoutMensagem_grupoInput>, pessoaUncheckedUpdateWithoutMensagem_grupoInput>
  }

  export type MessagesCreateNestedOneWithoutMensagem_privadaInput = {
    create?: XOR<MessagesCreateWithoutMensagem_privadaInput, MessagesUncheckedCreateWithoutMensagem_privadaInput>
    connectOrCreate?: MessagesCreateOrConnectWithoutMensagem_privadaInput
    connect?: MessagesWhereUniqueInput
  }

  export type pessoaCreateNestedOneWithoutMensagem_privadaInput = {
    create?: XOR<pessoaCreateWithoutMensagem_privadaInput, pessoaUncheckedCreateWithoutMensagem_privadaInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutMensagem_privadaInput
    connect?: pessoaWhereUniqueInput
  }

  export type MessagesUpdateOneRequiredWithoutMensagem_privadaNestedInput = {
    create?: XOR<MessagesCreateWithoutMensagem_privadaInput, MessagesUncheckedCreateWithoutMensagem_privadaInput>
    connectOrCreate?: MessagesCreateOrConnectWithoutMensagem_privadaInput
    upsert?: MessagesUpsertWithoutMensagem_privadaInput
    connect?: MessagesWhereUniqueInput
    update?: XOR<XOR<MessagesUpdateToOneWithWhereWithoutMensagem_privadaInput, MessagesUpdateWithoutMensagem_privadaInput>, MessagesUncheckedUpdateWithoutMensagem_privadaInput>
  }

  export type pessoaUpdateOneRequiredWithoutMensagem_privadaNestedInput = {
    create?: XOR<pessoaCreateWithoutMensagem_privadaInput, pessoaUncheckedCreateWithoutMensagem_privadaInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutMensagem_privadaInput
    upsert?: pessoaUpsertWithoutMensagem_privadaInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutMensagem_privadaInput, pessoaUpdateWithoutMensagem_privadaInput>, pessoaUncheckedUpdateWithoutMensagem_privadaInput>
  }

  export type MessagesCreateNestedManyWithoutPessoaInput = {
    create?: XOR<MessagesCreateWithoutPessoaInput, MessagesUncheckedCreateWithoutPessoaInput> | MessagesCreateWithoutPessoaInput[] | MessagesUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutPessoaInput | MessagesCreateOrConnectWithoutPessoaInput[]
    createMany?: MessagesCreateManyPessoaInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type grupos_pessoasCreateNestedManyWithoutPessoaInput = {
    create?: XOR<grupos_pessoasCreateWithoutPessoaInput, grupos_pessoasUncheckedCreateWithoutPessoaInput> | grupos_pessoasCreateWithoutPessoaInput[] | grupos_pessoasUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: grupos_pessoasCreateOrConnectWithoutPessoaInput | grupos_pessoasCreateOrConnectWithoutPessoaInput[]
    createMany?: grupos_pessoasCreateManyPessoaInputEnvelope
    connect?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
  }

  export type mensagem_grupoCreateNestedManyWithoutPessoaInput = {
    create?: XOR<mensagem_grupoCreateWithoutPessoaInput, mensagem_grupoUncheckedCreateWithoutPessoaInput> | mensagem_grupoCreateWithoutPessoaInput[] | mensagem_grupoUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: mensagem_grupoCreateOrConnectWithoutPessoaInput | mensagem_grupoCreateOrConnectWithoutPessoaInput[]
    createMany?: mensagem_grupoCreateManyPessoaInputEnvelope
    connect?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
  }

  export type mensagem_privadaCreateNestedManyWithoutPessoaInput = {
    create?: XOR<mensagem_privadaCreateWithoutPessoaInput, mensagem_privadaUncheckedCreateWithoutPessoaInput> | mensagem_privadaCreateWithoutPessoaInput[] | mensagem_privadaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: mensagem_privadaCreateOrConnectWithoutPessoaInput | mensagem_privadaCreateOrConnectWithoutPessoaInput[]
    createMany?: mensagem_privadaCreateManyPessoaInputEnvelope
    connect?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
  }

  export type MessagesUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<MessagesCreateWithoutPessoaInput, MessagesUncheckedCreateWithoutPessoaInput> | MessagesCreateWithoutPessoaInput[] | MessagesUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutPessoaInput | MessagesCreateOrConnectWithoutPessoaInput[]
    createMany?: MessagesCreateManyPessoaInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type grupos_pessoasUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<grupos_pessoasCreateWithoutPessoaInput, grupos_pessoasUncheckedCreateWithoutPessoaInput> | grupos_pessoasCreateWithoutPessoaInput[] | grupos_pessoasUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: grupos_pessoasCreateOrConnectWithoutPessoaInput | grupos_pessoasCreateOrConnectWithoutPessoaInput[]
    createMany?: grupos_pessoasCreateManyPessoaInputEnvelope
    connect?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
  }

  export type mensagem_grupoUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<mensagem_grupoCreateWithoutPessoaInput, mensagem_grupoUncheckedCreateWithoutPessoaInput> | mensagem_grupoCreateWithoutPessoaInput[] | mensagem_grupoUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: mensagem_grupoCreateOrConnectWithoutPessoaInput | mensagem_grupoCreateOrConnectWithoutPessoaInput[]
    createMany?: mensagem_grupoCreateManyPessoaInputEnvelope
    connect?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
  }

  export type mensagem_privadaUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<mensagem_privadaCreateWithoutPessoaInput, mensagem_privadaUncheckedCreateWithoutPessoaInput> | mensagem_privadaCreateWithoutPessoaInput[] | mensagem_privadaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: mensagem_privadaCreateOrConnectWithoutPessoaInput | mensagem_privadaCreateOrConnectWithoutPessoaInput[]
    createMany?: mensagem_privadaCreateManyPessoaInputEnvelope
    connect?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
  }

  export type MessagesUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<MessagesCreateWithoutPessoaInput, MessagesUncheckedCreateWithoutPessoaInput> | MessagesCreateWithoutPessoaInput[] | MessagesUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutPessoaInput | MessagesCreateOrConnectWithoutPessoaInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutPessoaInput | MessagesUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: MessagesCreateManyPessoaInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutPessoaInput | MessagesUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutPessoaInput | MessagesUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type grupos_pessoasUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<grupos_pessoasCreateWithoutPessoaInput, grupos_pessoasUncheckedCreateWithoutPessoaInput> | grupos_pessoasCreateWithoutPessoaInput[] | grupos_pessoasUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: grupos_pessoasCreateOrConnectWithoutPessoaInput | grupos_pessoasCreateOrConnectWithoutPessoaInput[]
    upsert?: grupos_pessoasUpsertWithWhereUniqueWithoutPessoaInput | grupos_pessoasUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: grupos_pessoasCreateManyPessoaInputEnvelope
    set?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    disconnect?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    delete?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    connect?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    update?: grupos_pessoasUpdateWithWhereUniqueWithoutPessoaInput | grupos_pessoasUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: grupos_pessoasUpdateManyWithWhereWithoutPessoaInput | grupos_pessoasUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: grupos_pessoasScalarWhereInput | grupos_pessoasScalarWhereInput[]
  }

  export type mensagem_grupoUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<mensagem_grupoCreateWithoutPessoaInput, mensagem_grupoUncheckedCreateWithoutPessoaInput> | mensagem_grupoCreateWithoutPessoaInput[] | mensagem_grupoUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: mensagem_grupoCreateOrConnectWithoutPessoaInput | mensagem_grupoCreateOrConnectWithoutPessoaInput[]
    upsert?: mensagem_grupoUpsertWithWhereUniqueWithoutPessoaInput | mensagem_grupoUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: mensagem_grupoCreateManyPessoaInputEnvelope
    set?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    disconnect?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    delete?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    connect?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    update?: mensagem_grupoUpdateWithWhereUniqueWithoutPessoaInput | mensagem_grupoUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: mensagem_grupoUpdateManyWithWhereWithoutPessoaInput | mensagem_grupoUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: mensagem_grupoScalarWhereInput | mensagem_grupoScalarWhereInput[]
  }

  export type mensagem_privadaUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<mensagem_privadaCreateWithoutPessoaInput, mensagem_privadaUncheckedCreateWithoutPessoaInput> | mensagem_privadaCreateWithoutPessoaInput[] | mensagem_privadaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: mensagem_privadaCreateOrConnectWithoutPessoaInput | mensagem_privadaCreateOrConnectWithoutPessoaInput[]
    upsert?: mensagem_privadaUpsertWithWhereUniqueWithoutPessoaInput | mensagem_privadaUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: mensagem_privadaCreateManyPessoaInputEnvelope
    set?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    disconnect?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    delete?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    connect?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    update?: mensagem_privadaUpdateWithWhereUniqueWithoutPessoaInput | mensagem_privadaUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: mensagem_privadaUpdateManyWithWhereWithoutPessoaInput | mensagem_privadaUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: mensagem_privadaScalarWhereInput | mensagem_privadaScalarWhereInput[]
  }

  export type MessagesUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<MessagesCreateWithoutPessoaInput, MessagesUncheckedCreateWithoutPessoaInput> | MessagesCreateWithoutPessoaInput[] | MessagesUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutPessoaInput | MessagesCreateOrConnectWithoutPessoaInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutPessoaInput | MessagesUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: MessagesCreateManyPessoaInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutPessoaInput | MessagesUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutPessoaInput | MessagesUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type grupos_pessoasUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<grupos_pessoasCreateWithoutPessoaInput, grupos_pessoasUncheckedCreateWithoutPessoaInput> | grupos_pessoasCreateWithoutPessoaInput[] | grupos_pessoasUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: grupos_pessoasCreateOrConnectWithoutPessoaInput | grupos_pessoasCreateOrConnectWithoutPessoaInput[]
    upsert?: grupos_pessoasUpsertWithWhereUniqueWithoutPessoaInput | grupos_pessoasUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: grupos_pessoasCreateManyPessoaInputEnvelope
    set?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    disconnect?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    delete?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    connect?: grupos_pessoasWhereUniqueInput | grupos_pessoasWhereUniqueInput[]
    update?: grupos_pessoasUpdateWithWhereUniqueWithoutPessoaInput | grupos_pessoasUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: grupos_pessoasUpdateManyWithWhereWithoutPessoaInput | grupos_pessoasUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: grupos_pessoasScalarWhereInput | grupos_pessoasScalarWhereInput[]
  }

  export type mensagem_grupoUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<mensagem_grupoCreateWithoutPessoaInput, mensagem_grupoUncheckedCreateWithoutPessoaInput> | mensagem_grupoCreateWithoutPessoaInput[] | mensagem_grupoUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: mensagem_grupoCreateOrConnectWithoutPessoaInput | mensagem_grupoCreateOrConnectWithoutPessoaInput[]
    upsert?: mensagem_grupoUpsertWithWhereUniqueWithoutPessoaInput | mensagem_grupoUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: mensagem_grupoCreateManyPessoaInputEnvelope
    set?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    disconnect?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    delete?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    connect?: mensagem_grupoWhereUniqueInput | mensagem_grupoWhereUniqueInput[]
    update?: mensagem_grupoUpdateWithWhereUniqueWithoutPessoaInput | mensagem_grupoUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: mensagem_grupoUpdateManyWithWhereWithoutPessoaInput | mensagem_grupoUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: mensagem_grupoScalarWhereInput | mensagem_grupoScalarWhereInput[]
  }

  export type mensagem_privadaUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<mensagem_privadaCreateWithoutPessoaInput, mensagem_privadaUncheckedCreateWithoutPessoaInput> | mensagem_privadaCreateWithoutPessoaInput[] | mensagem_privadaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: mensagem_privadaCreateOrConnectWithoutPessoaInput | mensagem_privadaCreateOrConnectWithoutPessoaInput[]
    upsert?: mensagem_privadaUpsertWithWhereUniqueWithoutPessoaInput | mensagem_privadaUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: mensagem_privadaCreateManyPessoaInputEnvelope
    set?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    disconnect?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    delete?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    connect?: mensagem_privadaWhereUniqueInput | mensagem_privadaWhereUniqueInput[]
    update?: mensagem_privadaUpdateWithWhereUniqueWithoutPessoaInput | mensagem_privadaUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: mensagem_privadaUpdateManyWithWhereWithoutPessoaInput | mensagem_privadaUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: mensagem_privadaScalarWhereInput | mensagem_privadaScalarWhereInput[]
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type grupoCreateWithoutMessagesInput = {
    id?: bigint | number
    nome?: string
    descricao?: string | null
    grupos_pessoas?: grupos_pessoasCreateNestedManyWithoutGrupoInput
  }

  export type grupoUncheckedCreateWithoutMessagesInput = {
    id?: bigint | number
    nome?: string
    descricao?: string | null
    grupos_pessoas?: grupos_pessoasUncheckedCreateNestedManyWithoutGrupoInput
  }

  export type grupoCreateOrConnectWithoutMessagesInput = {
    where: grupoWhereUniqueInput
    create: XOR<grupoCreateWithoutMessagesInput, grupoUncheckedCreateWithoutMessagesInput>
  }

  export type pessoaCreateWithoutMessagesInput = {
    id?: bigint | number
    nome?: string
    email?: string
    senha: string
    cpf?: string
    data_cadastro?: Date | string
    grupos_pessoas?: grupos_pessoasCreateNestedManyWithoutPessoaInput
    mensagem_grupo?: mensagem_grupoCreateNestedManyWithoutPessoaInput
    mensagem_privada?: mensagem_privadaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutMessagesInput = {
    id?: bigint | number
    nome?: string
    email?: string
    senha: string
    cpf?: string
    data_cadastro?: Date | string
    grupos_pessoas?: grupos_pessoasUncheckedCreateNestedManyWithoutPessoaInput
    mensagem_grupo?: mensagem_grupoUncheckedCreateNestedManyWithoutPessoaInput
    mensagem_privada?: mensagem_privadaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutMessagesInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutMessagesInput, pessoaUncheckedCreateWithoutMessagesInput>
  }

  export type mensagem_grupoCreateWithoutMessagesInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    pessoa: pessoaCreateNestedOneWithoutMensagem_grupoInput
  }

  export type mensagem_grupoUncheckedCreateWithoutMessagesInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    id_pessoa: bigint | number
  }

  export type mensagem_grupoCreateOrConnectWithoutMessagesInput = {
    where: mensagem_grupoWhereUniqueInput
    create: XOR<mensagem_grupoCreateWithoutMessagesInput, mensagem_grupoUncheckedCreateWithoutMessagesInput>
  }

  export type mensagem_grupoCreateManyMessagesInputEnvelope = {
    data: mensagem_grupoCreateManyMessagesInput | mensagem_grupoCreateManyMessagesInput[]
    skipDuplicates?: boolean
  }

  export type mensagem_privadaCreateWithoutMessagesInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    pessoa: pessoaCreateNestedOneWithoutMensagem_privadaInput
  }

  export type mensagem_privadaUncheckedCreateWithoutMessagesInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    id_pessoa: bigint | number
  }

  export type mensagem_privadaCreateOrConnectWithoutMessagesInput = {
    where: mensagem_privadaWhereUniqueInput
    create: XOR<mensagem_privadaCreateWithoutMessagesInput, mensagem_privadaUncheckedCreateWithoutMessagesInput>
  }

  export type mensagem_privadaCreateManyMessagesInputEnvelope = {
    data: mensagem_privadaCreateManyMessagesInput | mensagem_privadaCreateManyMessagesInput[]
    skipDuplicates?: boolean
  }

  export type grupoUpsertWithoutMessagesInput = {
    update: XOR<grupoUpdateWithoutMessagesInput, grupoUncheckedUpdateWithoutMessagesInput>
    create: XOR<grupoCreateWithoutMessagesInput, grupoUncheckedCreateWithoutMessagesInput>
    where?: grupoWhereInput
  }

  export type grupoUpdateToOneWithWhereWithoutMessagesInput = {
    where?: grupoWhereInput
    data: XOR<grupoUpdateWithoutMessagesInput, grupoUncheckedUpdateWithoutMessagesInput>
  }

  export type grupoUpdateWithoutMessagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    grupos_pessoas?: grupos_pessoasUpdateManyWithoutGrupoNestedInput
  }

  export type grupoUncheckedUpdateWithoutMessagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    grupos_pessoas?: grupos_pessoasUncheckedUpdateManyWithoutGrupoNestedInput
  }

  export type pessoaUpsertWithoutMessagesInput = {
    update: XOR<pessoaUpdateWithoutMessagesInput, pessoaUncheckedUpdateWithoutMessagesInput>
    create: XOR<pessoaCreateWithoutMessagesInput, pessoaUncheckedCreateWithoutMessagesInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutMessagesInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutMessagesInput, pessoaUncheckedUpdateWithoutMessagesInput>
  }

  export type pessoaUpdateWithoutMessagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    grupos_pessoas?: grupos_pessoasUpdateManyWithoutPessoaNestedInput
    mensagem_grupo?: mensagem_grupoUpdateManyWithoutPessoaNestedInput
    mensagem_privada?: mensagem_privadaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutMessagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    grupos_pessoas?: grupos_pessoasUncheckedUpdateManyWithoutPessoaNestedInput
    mensagem_grupo?: mensagem_grupoUncheckedUpdateManyWithoutPessoaNestedInput
    mensagem_privada?: mensagem_privadaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type mensagem_grupoUpsertWithWhereUniqueWithoutMessagesInput = {
    where: mensagem_grupoWhereUniqueInput
    update: XOR<mensagem_grupoUpdateWithoutMessagesInput, mensagem_grupoUncheckedUpdateWithoutMessagesInput>
    create: XOR<mensagem_grupoCreateWithoutMessagesInput, mensagem_grupoUncheckedCreateWithoutMessagesInput>
  }

  export type mensagem_grupoUpdateWithWhereUniqueWithoutMessagesInput = {
    where: mensagem_grupoWhereUniqueInput
    data: XOR<mensagem_grupoUpdateWithoutMessagesInput, mensagem_grupoUncheckedUpdateWithoutMessagesInput>
  }

  export type mensagem_grupoUpdateManyWithWhereWithoutMessagesInput = {
    where: mensagem_grupoScalarWhereInput
    data: XOR<mensagem_grupoUpdateManyMutationInput, mensagem_grupoUncheckedUpdateManyWithoutMessagesInput>
  }

  export type mensagem_grupoScalarWhereInput = {
    AND?: mensagem_grupoScalarWhereInput | mensagem_grupoScalarWhereInput[]
    OR?: mensagem_grupoScalarWhereInput[]
    NOT?: mensagem_grupoScalarWhereInput | mensagem_grupoScalarWhereInput[]
    id?: BigIntFilter<"mensagem_grupo"> | bigint | number
    mensagem?: StringFilter<"mensagem_grupo"> | string
    data_cadastro?: DateTimeFilter<"mensagem_grupo"> | Date | string
    id_Messages?: BigIntFilter<"mensagem_grupo"> | bigint | number
    id_pessoa?: BigIntFilter<"mensagem_grupo"> | bigint | number
  }

  export type mensagem_privadaUpsertWithWhereUniqueWithoutMessagesInput = {
    where: mensagem_privadaWhereUniqueInput
    update: XOR<mensagem_privadaUpdateWithoutMessagesInput, mensagem_privadaUncheckedUpdateWithoutMessagesInput>
    create: XOR<mensagem_privadaCreateWithoutMessagesInput, mensagem_privadaUncheckedCreateWithoutMessagesInput>
  }

  export type mensagem_privadaUpdateWithWhereUniqueWithoutMessagesInput = {
    where: mensagem_privadaWhereUniqueInput
    data: XOR<mensagem_privadaUpdateWithoutMessagesInput, mensagem_privadaUncheckedUpdateWithoutMessagesInput>
  }

  export type mensagem_privadaUpdateManyWithWhereWithoutMessagesInput = {
    where: mensagem_privadaScalarWhereInput
    data: XOR<mensagem_privadaUpdateManyMutationInput, mensagem_privadaUncheckedUpdateManyWithoutMessagesInput>
  }

  export type mensagem_privadaScalarWhereInput = {
    AND?: mensagem_privadaScalarWhereInput | mensagem_privadaScalarWhereInput[]
    OR?: mensagem_privadaScalarWhereInput[]
    NOT?: mensagem_privadaScalarWhereInput | mensagem_privadaScalarWhereInput[]
    id?: BigIntFilter<"mensagem_privada"> | bigint | number
    mensagem?: StringFilter<"mensagem_privada"> | string
    data_cadastro?: DateTimeFilter<"mensagem_privada"> | Date | string
    id_Messages?: BigIntFilter<"mensagem_privada"> | bigint | number
    id_pessoa?: BigIntFilter<"mensagem_privada"> | bigint | number
  }

  export type MessagesCreateWithoutGrupoInput = {
    id?: bigint | number
    id_receptor?: bigint | number | null
    data_cadastro?: Date | string
    pessoa: pessoaCreateNestedOneWithoutMessagesInput
    mensagem_grupo?: mensagem_grupoCreateNestedManyWithoutMessagesInput
    mensagem_privada?: mensagem_privadaCreateNestedManyWithoutMessagesInput
  }

  export type MessagesUncheckedCreateWithoutGrupoInput = {
    id?: bigint | number
    id_receptor?: bigint | number | null
    data_cadastro?: Date | string
    id_pessoa: bigint | number
    mensagem_grupo?: mensagem_grupoUncheckedCreateNestedManyWithoutMessagesInput
    mensagem_privada?: mensagem_privadaUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type MessagesCreateOrConnectWithoutGrupoInput = {
    where: MessagesWhereUniqueInput
    create: XOR<MessagesCreateWithoutGrupoInput, MessagesUncheckedCreateWithoutGrupoInput>
  }

  export type MessagesCreateManyGrupoInputEnvelope = {
    data: MessagesCreateManyGrupoInput | MessagesCreateManyGrupoInput[]
    skipDuplicates?: boolean
  }

  export type grupos_pessoasCreateWithoutGrupoInput = {
    id?: bigint | number
    data_cadastro?: Date | string
    pessoa: pessoaCreateNestedOneWithoutGrupos_pessoasInput
  }

  export type grupos_pessoasUncheckedCreateWithoutGrupoInput = {
    id?: bigint | number
    data_cadastro?: Date | string
    id_pessoa: bigint | number
  }

  export type grupos_pessoasCreateOrConnectWithoutGrupoInput = {
    where: grupos_pessoasWhereUniqueInput
    create: XOR<grupos_pessoasCreateWithoutGrupoInput, grupos_pessoasUncheckedCreateWithoutGrupoInput>
  }

  export type grupos_pessoasCreateManyGrupoInputEnvelope = {
    data: grupos_pessoasCreateManyGrupoInput | grupos_pessoasCreateManyGrupoInput[]
    skipDuplicates?: boolean
  }

  export type MessagesUpsertWithWhereUniqueWithoutGrupoInput = {
    where: MessagesWhereUniqueInput
    update: XOR<MessagesUpdateWithoutGrupoInput, MessagesUncheckedUpdateWithoutGrupoInput>
    create: XOR<MessagesCreateWithoutGrupoInput, MessagesUncheckedCreateWithoutGrupoInput>
  }

  export type MessagesUpdateWithWhereUniqueWithoutGrupoInput = {
    where: MessagesWhereUniqueInput
    data: XOR<MessagesUpdateWithoutGrupoInput, MessagesUncheckedUpdateWithoutGrupoInput>
  }

  export type MessagesUpdateManyWithWhereWithoutGrupoInput = {
    where: MessagesScalarWhereInput
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyWithoutGrupoInput>
  }

  export type MessagesScalarWhereInput = {
    AND?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
    OR?: MessagesScalarWhereInput[]
    NOT?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
    id?: BigIntFilter<"Messages"> | bigint | number
    id_receptor?: BigIntNullableFilter<"Messages"> | bigint | number | null
    data_cadastro?: DateTimeFilter<"Messages"> | Date | string
    id_pessoa?: BigIntFilter<"Messages"> | bigint | number
    id_grupo?: BigIntNullableFilter<"Messages"> | bigint | number | null
  }

  export type grupos_pessoasUpsertWithWhereUniqueWithoutGrupoInput = {
    where: grupos_pessoasWhereUniqueInput
    update: XOR<grupos_pessoasUpdateWithoutGrupoInput, grupos_pessoasUncheckedUpdateWithoutGrupoInput>
    create: XOR<grupos_pessoasCreateWithoutGrupoInput, grupos_pessoasUncheckedCreateWithoutGrupoInput>
  }

  export type grupos_pessoasUpdateWithWhereUniqueWithoutGrupoInput = {
    where: grupos_pessoasWhereUniqueInput
    data: XOR<grupos_pessoasUpdateWithoutGrupoInput, grupos_pessoasUncheckedUpdateWithoutGrupoInput>
  }

  export type grupos_pessoasUpdateManyWithWhereWithoutGrupoInput = {
    where: grupos_pessoasScalarWhereInput
    data: XOR<grupos_pessoasUpdateManyMutationInput, grupos_pessoasUncheckedUpdateManyWithoutGrupoInput>
  }

  export type grupos_pessoasScalarWhereInput = {
    AND?: grupos_pessoasScalarWhereInput | grupos_pessoasScalarWhereInput[]
    OR?: grupos_pessoasScalarWhereInput[]
    NOT?: grupos_pessoasScalarWhereInput | grupos_pessoasScalarWhereInput[]
    id?: BigIntFilter<"grupos_pessoas"> | bigint | number
    data_cadastro?: DateTimeFilter<"grupos_pessoas"> | Date | string
    id_pessoa?: BigIntFilter<"grupos_pessoas"> | bigint | number
    id_grupo?: BigIntFilter<"grupos_pessoas"> | bigint | number
  }

  export type grupoCreateWithoutGrupos_pessoasInput = {
    id?: bigint | number
    nome?: string
    descricao?: string | null
    Messages?: MessagesCreateNestedManyWithoutGrupoInput
  }

  export type grupoUncheckedCreateWithoutGrupos_pessoasInput = {
    id?: bigint | number
    nome?: string
    descricao?: string | null
    Messages?: MessagesUncheckedCreateNestedManyWithoutGrupoInput
  }

  export type grupoCreateOrConnectWithoutGrupos_pessoasInput = {
    where: grupoWhereUniqueInput
    create: XOR<grupoCreateWithoutGrupos_pessoasInput, grupoUncheckedCreateWithoutGrupos_pessoasInput>
  }

  export type pessoaCreateWithoutGrupos_pessoasInput = {
    id?: bigint | number
    nome?: string
    email?: string
    senha: string
    cpf?: string
    data_cadastro?: Date | string
    Messages?: MessagesCreateNestedManyWithoutPessoaInput
    mensagem_grupo?: mensagem_grupoCreateNestedManyWithoutPessoaInput
    mensagem_privada?: mensagem_privadaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutGrupos_pessoasInput = {
    id?: bigint | number
    nome?: string
    email?: string
    senha: string
    cpf?: string
    data_cadastro?: Date | string
    Messages?: MessagesUncheckedCreateNestedManyWithoutPessoaInput
    mensagem_grupo?: mensagem_grupoUncheckedCreateNestedManyWithoutPessoaInput
    mensagem_privada?: mensagem_privadaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutGrupos_pessoasInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutGrupos_pessoasInput, pessoaUncheckedCreateWithoutGrupos_pessoasInput>
  }

  export type grupoUpsertWithoutGrupos_pessoasInput = {
    update: XOR<grupoUpdateWithoutGrupos_pessoasInput, grupoUncheckedUpdateWithoutGrupos_pessoasInput>
    create: XOR<grupoCreateWithoutGrupos_pessoasInput, grupoUncheckedCreateWithoutGrupos_pessoasInput>
    where?: grupoWhereInput
  }

  export type grupoUpdateToOneWithWhereWithoutGrupos_pessoasInput = {
    where?: grupoWhereInput
    data: XOR<grupoUpdateWithoutGrupos_pessoasInput, grupoUncheckedUpdateWithoutGrupos_pessoasInput>
  }

  export type grupoUpdateWithoutGrupos_pessoasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    Messages?: MessagesUpdateManyWithoutGrupoNestedInput
  }

  export type grupoUncheckedUpdateWithoutGrupos_pessoasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    Messages?: MessagesUncheckedUpdateManyWithoutGrupoNestedInput
  }

  export type pessoaUpsertWithoutGrupos_pessoasInput = {
    update: XOR<pessoaUpdateWithoutGrupos_pessoasInput, pessoaUncheckedUpdateWithoutGrupos_pessoasInput>
    create: XOR<pessoaCreateWithoutGrupos_pessoasInput, pessoaUncheckedCreateWithoutGrupos_pessoasInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutGrupos_pessoasInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutGrupos_pessoasInput, pessoaUncheckedUpdateWithoutGrupos_pessoasInput>
  }

  export type pessoaUpdateWithoutGrupos_pessoasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    Messages?: MessagesUpdateManyWithoutPessoaNestedInput
    mensagem_grupo?: mensagem_grupoUpdateManyWithoutPessoaNestedInput
    mensagem_privada?: mensagem_privadaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutGrupos_pessoasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    Messages?: MessagesUncheckedUpdateManyWithoutPessoaNestedInput
    mensagem_grupo?: mensagem_grupoUncheckedUpdateManyWithoutPessoaNestedInput
    mensagem_privada?: mensagem_privadaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type MessagesCreateWithoutMensagem_grupoInput = {
    id?: bigint | number
    id_receptor?: bigint | number | null
    data_cadastro?: Date | string
    grupo?: grupoCreateNestedOneWithoutMessagesInput
    pessoa: pessoaCreateNestedOneWithoutMessagesInput
    mensagem_privada?: mensagem_privadaCreateNestedManyWithoutMessagesInput
  }

  export type MessagesUncheckedCreateWithoutMensagem_grupoInput = {
    id?: bigint | number
    id_receptor?: bigint | number | null
    data_cadastro?: Date | string
    id_pessoa: bigint | number
    id_grupo?: bigint | number | null
    mensagem_privada?: mensagem_privadaUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type MessagesCreateOrConnectWithoutMensagem_grupoInput = {
    where: MessagesWhereUniqueInput
    create: XOR<MessagesCreateWithoutMensagem_grupoInput, MessagesUncheckedCreateWithoutMensagem_grupoInput>
  }

  export type pessoaCreateWithoutMensagem_grupoInput = {
    id?: bigint | number
    nome?: string
    email?: string
    senha: string
    cpf?: string
    data_cadastro?: Date | string
    Messages?: MessagesCreateNestedManyWithoutPessoaInput
    grupos_pessoas?: grupos_pessoasCreateNestedManyWithoutPessoaInput
    mensagem_privada?: mensagem_privadaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutMensagem_grupoInput = {
    id?: bigint | number
    nome?: string
    email?: string
    senha: string
    cpf?: string
    data_cadastro?: Date | string
    Messages?: MessagesUncheckedCreateNestedManyWithoutPessoaInput
    grupos_pessoas?: grupos_pessoasUncheckedCreateNestedManyWithoutPessoaInput
    mensagem_privada?: mensagem_privadaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutMensagem_grupoInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutMensagem_grupoInput, pessoaUncheckedCreateWithoutMensagem_grupoInput>
  }

  export type MessagesUpsertWithoutMensagem_grupoInput = {
    update: XOR<MessagesUpdateWithoutMensagem_grupoInput, MessagesUncheckedUpdateWithoutMensagem_grupoInput>
    create: XOR<MessagesCreateWithoutMensagem_grupoInput, MessagesUncheckedCreateWithoutMensagem_grupoInput>
    where?: MessagesWhereInput
  }

  export type MessagesUpdateToOneWithWhereWithoutMensagem_grupoInput = {
    where?: MessagesWhereInput
    data: XOR<MessagesUpdateWithoutMensagem_grupoInput, MessagesUncheckedUpdateWithoutMensagem_grupoInput>
  }

  export type MessagesUpdateWithoutMensagem_grupoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    id_receptor?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    grupo?: grupoUpdateOneWithoutMessagesNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutMessagesNestedInput
    mensagem_privada?: mensagem_privadaUpdateManyWithoutMessagesNestedInput
  }

  export type MessagesUncheckedUpdateWithoutMensagem_grupoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    id_receptor?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
    id_grupo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mensagem_privada?: mensagem_privadaUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type pessoaUpsertWithoutMensagem_grupoInput = {
    update: XOR<pessoaUpdateWithoutMensagem_grupoInput, pessoaUncheckedUpdateWithoutMensagem_grupoInput>
    create: XOR<pessoaCreateWithoutMensagem_grupoInput, pessoaUncheckedCreateWithoutMensagem_grupoInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutMensagem_grupoInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutMensagem_grupoInput, pessoaUncheckedUpdateWithoutMensagem_grupoInput>
  }

  export type pessoaUpdateWithoutMensagem_grupoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    Messages?: MessagesUpdateManyWithoutPessoaNestedInput
    grupos_pessoas?: grupos_pessoasUpdateManyWithoutPessoaNestedInput
    mensagem_privada?: mensagem_privadaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutMensagem_grupoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    Messages?: MessagesUncheckedUpdateManyWithoutPessoaNestedInput
    grupos_pessoas?: grupos_pessoasUncheckedUpdateManyWithoutPessoaNestedInput
    mensagem_privada?: mensagem_privadaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type MessagesCreateWithoutMensagem_privadaInput = {
    id?: bigint | number
    id_receptor?: bigint | number | null
    data_cadastro?: Date | string
    grupo?: grupoCreateNestedOneWithoutMessagesInput
    pessoa: pessoaCreateNestedOneWithoutMessagesInput
    mensagem_grupo?: mensagem_grupoCreateNestedManyWithoutMessagesInput
  }

  export type MessagesUncheckedCreateWithoutMensagem_privadaInput = {
    id?: bigint | number
    id_receptor?: bigint | number | null
    data_cadastro?: Date | string
    id_pessoa: bigint | number
    id_grupo?: bigint | number | null
    mensagem_grupo?: mensagem_grupoUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type MessagesCreateOrConnectWithoutMensagem_privadaInput = {
    where: MessagesWhereUniqueInput
    create: XOR<MessagesCreateWithoutMensagem_privadaInput, MessagesUncheckedCreateWithoutMensagem_privadaInput>
  }

  export type pessoaCreateWithoutMensagem_privadaInput = {
    id?: bigint | number
    nome?: string
    email?: string
    senha: string
    cpf?: string
    data_cadastro?: Date | string
    Messages?: MessagesCreateNestedManyWithoutPessoaInput
    grupos_pessoas?: grupos_pessoasCreateNestedManyWithoutPessoaInput
    mensagem_grupo?: mensagem_grupoCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutMensagem_privadaInput = {
    id?: bigint | number
    nome?: string
    email?: string
    senha: string
    cpf?: string
    data_cadastro?: Date | string
    Messages?: MessagesUncheckedCreateNestedManyWithoutPessoaInput
    grupos_pessoas?: grupos_pessoasUncheckedCreateNestedManyWithoutPessoaInput
    mensagem_grupo?: mensagem_grupoUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutMensagem_privadaInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutMensagem_privadaInput, pessoaUncheckedCreateWithoutMensagem_privadaInput>
  }

  export type MessagesUpsertWithoutMensagem_privadaInput = {
    update: XOR<MessagesUpdateWithoutMensagem_privadaInput, MessagesUncheckedUpdateWithoutMensagem_privadaInput>
    create: XOR<MessagesCreateWithoutMensagem_privadaInput, MessagesUncheckedCreateWithoutMensagem_privadaInput>
    where?: MessagesWhereInput
  }

  export type MessagesUpdateToOneWithWhereWithoutMensagem_privadaInput = {
    where?: MessagesWhereInput
    data: XOR<MessagesUpdateWithoutMensagem_privadaInput, MessagesUncheckedUpdateWithoutMensagem_privadaInput>
  }

  export type MessagesUpdateWithoutMensagem_privadaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    id_receptor?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    grupo?: grupoUpdateOneWithoutMessagesNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutMessagesNestedInput
    mensagem_grupo?: mensagem_grupoUpdateManyWithoutMessagesNestedInput
  }

  export type MessagesUncheckedUpdateWithoutMensagem_privadaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    id_receptor?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
    id_grupo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mensagem_grupo?: mensagem_grupoUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type pessoaUpsertWithoutMensagem_privadaInput = {
    update: XOR<pessoaUpdateWithoutMensagem_privadaInput, pessoaUncheckedUpdateWithoutMensagem_privadaInput>
    create: XOR<pessoaCreateWithoutMensagem_privadaInput, pessoaUncheckedCreateWithoutMensagem_privadaInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutMensagem_privadaInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutMensagem_privadaInput, pessoaUncheckedUpdateWithoutMensagem_privadaInput>
  }

  export type pessoaUpdateWithoutMensagem_privadaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    Messages?: MessagesUpdateManyWithoutPessoaNestedInput
    grupos_pessoas?: grupos_pessoasUpdateManyWithoutPessoaNestedInput
    mensagem_grupo?: mensagem_grupoUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutMensagem_privadaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    Messages?: MessagesUncheckedUpdateManyWithoutPessoaNestedInput
    grupos_pessoas?: grupos_pessoasUncheckedUpdateManyWithoutPessoaNestedInput
    mensagem_grupo?: mensagem_grupoUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type MessagesCreateWithoutPessoaInput = {
    id?: bigint | number
    id_receptor?: bigint | number | null
    data_cadastro?: Date | string
    grupo?: grupoCreateNestedOneWithoutMessagesInput
    mensagem_grupo?: mensagem_grupoCreateNestedManyWithoutMessagesInput
    mensagem_privada?: mensagem_privadaCreateNestedManyWithoutMessagesInput
  }

  export type MessagesUncheckedCreateWithoutPessoaInput = {
    id?: bigint | number
    id_receptor?: bigint | number | null
    data_cadastro?: Date | string
    id_grupo?: bigint | number | null
    mensagem_grupo?: mensagem_grupoUncheckedCreateNestedManyWithoutMessagesInput
    mensagem_privada?: mensagem_privadaUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type MessagesCreateOrConnectWithoutPessoaInput = {
    where: MessagesWhereUniqueInput
    create: XOR<MessagesCreateWithoutPessoaInput, MessagesUncheckedCreateWithoutPessoaInput>
  }

  export type MessagesCreateManyPessoaInputEnvelope = {
    data: MessagesCreateManyPessoaInput | MessagesCreateManyPessoaInput[]
    skipDuplicates?: boolean
  }

  export type grupos_pessoasCreateWithoutPessoaInput = {
    id?: bigint | number
    data_cadastro?: Date | string
    grupo: grupoCreateNestedOneWithoutGrupos_pessoasInput
  }

  export type grupos_pessoasUncheckedCreateWithoutPessoaInput = {
    id?: bigint | number
    data_cadastro?: Date | string
    id_grupo: bigint | number
  }

  export type grupos_pessoasCreateOrConnectWithoutPessoaInput = {
    where: grupos_pessoasWhereUniqueInput
    create: XOR<grupos_pessoasCreateWithoutPessoaInput, grupos_pessoasUncheckedCreateWithoutPessoaInput>
  }

  export type grupos_pessoasCreateManyPessoaInputEnvelope = {
    data: grupos_pessoasCreateManyPessoaInput | grupos_pessoasCreateManyPessoaInput[]
    skipDuplicates?: boolean
  }

  export type mensagem_grupoCreateWithoutPessoaInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    Messages: MessagesCreateNestedOneWithoutMensagem_grupoInput
  }

  export type mensagem_grupoUncheckedCreateWithoutPessoaInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    id_Messages: bigint | number
  }

  export type mensagem_grupoCreateOrConnectWithoutPessoaInput = {
    where: mensagem_grupoWhereUniqueInput
    create: XOR<mensagem_grupoCreateWithoutPessoaInput, mensagem_grupoUncheckedCreateWithoutPessoaInput>
  }

  export type mensagem_grupoCreateManyPessoaInputEnvelope = {
    data: mensagem_grupoCreateManyPessoaInput | mensagem_grupoCreateManyPessoaInput[]
    skipDuplicates?: boolean
  }

  export type mensagem_privadaCreateWithoutPessoaInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    Messages: MessagesCreateNestedOneWithoutMensagem_privadaInput
  }

  export type mensagem_privadaUncheckedCreateWithoutPessoaInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    id_Messages: bigint | number
  }

  export type mensagem_privadaCreateOrConnectWithoutPessoaInput = {
    where: mensagem_privadaWhereUniqueInput
    create: XOR<mensagem_privadaCreateWithoutPessoaInput, mensagem_privadaUncheckedCreateWithoutPessoaInput>
  }

  export type mensagem_privadaCreateManyPessoaInputEnvelope = {
    data: mensagem_privadaCreateManyPessoaInput | mensagem_privadaCreateManyPessoaInput[]
    skipDuplicates?: boolean
  }

  export type MessagesUpsertWithWhereUniqueWithoutPessoaInput = {
    where: MessagesWhereUniqueInput
    update: XOR<MessagesUpdateWithoutPessoaInput, MessagesUncheckedUpdateWithoutPessoaInput>
    create: XOR<MessagesCreateWithoutPessoaInput, MessagesUncheckedCreateWithoutPessoaInput>
  }

  export type MessagesUpdateWithWhereUniqueWithoutPessoaInput = {
    where: MessagesWhereUniqueInput
    data: XOR<MessagesUpdateWithoutPessoaInput, MessagesUncheckedUpdateWithoutPessoaInput>
  }

  export type MessagesUpdateManyWithWhereWithoutPessoaInput = {
    where: MessagesScalarWhereInput
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyWithoutPessoaInput>
  }

  export type grupos_pessoasUpsertWithWhereUniqueWithoutPessoaInput = {
    where: grupos_pessoasWhereUniqueInput
    update: XOR<grupos_pessoasUpdateWithoutPessoaInput, grupos_pessoasUncheckedUpdateWithoutPessoaInput>
    create: XOR<grupos_pessoasCreateWithoutPessoaInput, grupos_pessoasUncheckedCreateWithoutPessoaInput>
  }

  export type grupos_pessoasUpdateWithWhereUniqueWithoutPessoaInput = {
    where: grupos_pessoasWhereUniqueInput
    data: XOR<grupos_pessoasUpdateWithoutPessoaInput, grupos_pessoasUncheckedUpdateWithoutPessoaInput>
  }

  export type grupos_pessoasUpdateManyWithWhereWithoutPessoaInput = {
    where: grupos_pessoasScalarWhereInput
    data: XOR<grupos_pessoasUpdateManyMutationInput, grupos_pessoasUncheckedUpdateManyWithoutPessoaInput>
  }

  export type mensagem_grupoUpsertWithWhereUniqueWithoutPessoaInput = {
    where: mensagem_grupoWhereUniqueInput
    update: XOR<mensagem_grupoUpdateWithoutPessoaInput, mensagem_grupoUncheckedUpdateWithoutPessoaInput>
    create: XOR<mensagem_grupoCreateWithoutPessoaInput, mensagem_grupoUncheckedCreateWithoutPessoaInput>
  }

  export type mensagem_grupoUpdateWithWhereUniqueWithoutPessoaInput = {
    where: mensagem_grupoWhereUniqueInput
    data: XOR<mensagem_grupoUpdateWithoutPessoaInput, mensagem_grupoUncheckedUpdateWithoutPessoaInput>
  }

  export type mensagem_grupoUpdateManyWithWhereWithoutPessoaInput = {
    where: mensagem_grupoScalarWhereInput
    data: XOR<mensagem_grupoUpdateManyMutationInput, mensagem_grupoUncheckedUpdateManyWithoutPessoaInput>
  }

  export type mensagem_privadaUpsertWithWhereUniqueWithoutPessoaInput = {
    where: mensagem_privadaWhereUniqueInput
    update: XOR<mensagem_privadaUpdateWithoutPessoaInput, mensagem_privadaUncheckedUpdateWithoutPessoaInput>
    create: XOR<mensagem_privadaCreateWithoutPessoaInput, mensagem_privadaUncheckedCreateWithoutPessoaInput>
  }

  export type mensagem_privadaUpdateWithWhereUniqueWithoutPessoaInput = {
    where: mensagem_privadaWhereUniqueInput
    data: XOR<mensagem_privadaUpdateWithoutPessoaInput, mensagem_privadaUncheckedUpdateWithoutPessoaInput>
  }

  export type mensagem_privadaUpdateManyWithWhereWithoutPessoaInput = {
    where: mensagem_privadaScalarWhereInput
    data: XOR<mensagem_privadaUpdateManyMutationInput, mensagem_privadaUncheckedUpdateManyWithoutPessoaInput>
  }

  export type mensagem_grupoCreateManyMessagesInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    id_pessoa: bigint | number
  }

  export type mensagem_privadaCreateManyMessagesInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    id_pessoa: bigint | number
  }

  export type mensagem_grupoUpdateWithoutMessagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa?: pessoaUpdateOneRequiredWithoutMensagem_grupoNestedInput
  }

  export type mensagem_grupoUncheckedUpdateWithoutMessagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type mensagem_grupoUncheckedUpdateManyWithoutMessagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type mensagem_privadaUpdateWithoutMessagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa?: pessoaUpdateOneRequiredWithoutMensagem_privadaNestedInput
  }

  export type mensagem_privadaUncheckedUpdateWithoutMessagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type mensagem_privadaUncheckedUpdateManyWithoutMessagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MessagesCreateManyGrupoInput = {
    id?: bigint | number
    id_receptor?: bigint | number | null
    data_cadastro?: Date | string
    id_pessoa: bigint | number
  }

  export type grupos_pessoasCreateManyGrupoInput = {
    id?: bigint | number
    data_cadastro?: Date | string
    id_pessoa: bigint | number
  }

  export type MessagesUpdateWithoutGrupoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    id_receptor?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa?: pessoaUpdateOneRequiredWithoutMessagesNestedInput
    mensagem_grupo?: mensagem_grupoUpdateManyWithoutMessagesNestedInput
    mensagem_privada?: mensagem_privadaUpdateManyWithoutMessagesNestedInput
  }

  export type MessagesUncheckedUpdateWithoutGrupoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    id_receptor?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem_grupo?: mensagem_grupoUncheckedUpdateManyWithoutMessagesNestedInput
    mensagem_privada?: mensagem_privadaUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type MessagesUncheckedUpdateManyWithoutGrupoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    id_receptor?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type grupos_pessoasUpdateWithoutGrupoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    pessoa?: pessoaUpdateOneRequiredWithoutGrupos_pessoasNestedInput
  }

  export type grupos_pessoasUncheckedUpdateWithoutGrupoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type grupos_pessoasUncheckedUpdateManyWithoutGrupoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pessoa?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MessagesCreateManyPessoaInput = {
    id?: bigint | number
    id_receptor?: bigint | number | null
    data_cadastro?: Date | string
    id_grupo?: bigint | number | null
  }

  export type grupos_pessoasCreateManyPessoaInput = {
    id?: bigint | number
    data_cadastro?: Date | string
    id_grupo: bigint | number
  }

  export type mensagem_grupoCreateManyPessoaInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    id_Messages: bigint | number
  }

  export type mensagem_privadaCreateManyPessoaInput = {
    id?: bigint | number
    mensagem: string
    data_cadastro?: Date | string
    id_Messages: bigint | number
  }

  export type MessagesUpdateWithoutPessoaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    id_receptor?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    grupo?: grupoUpdateOneWithoutMessagesNestedInput
    mensagem_grupo?: mensagem_grupoUpdateManyWithoutMessagesNestedInput
    mensagem_privada?: mensagem_privadaUpdateManyWithoutMessagesNestedInput
  }

  export type MessagesUncheckedUpdateWithoutPessoaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    id_receptor?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_grupo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mensagem_grupo?: mensagem_grupoUncheckedUpdateManyWithoutMessagesNestedInput
    mensagem_privada?: mensagem_privadaUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type MessagesUncheckedUpdateManyWithoutPessoaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    id_receptor?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_grupo?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type grupos_pessoasUpdateWithoutPessoaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    grupo?: grupoUpdateOneRequiredWithoutGrupos_pessoasNestedInput
  }

  export type grupos_pessoasUncheckedUpdateWithoutPessoaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_grupo?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type grupos_pessoasUncheckedUpdateManyWithoutPessoaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_grupo?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type mensagem_grupoUpdateWithoutPessoaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    Messages?: MessagesUpdateOneRequiredWithoutMensagem_grupoNestedInput
  }

  export type mensagem_grupoUncheckedUpdateWithoutPessoaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_Messages?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type mensagem_grupoUncheckedUpdateManyWithoutPessoaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_Messages?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type mensagem_privadaUpdateWithoutPessoaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    Messages?: MessagesUpdateOneRequiredWithoutMensagem_privadaNestedInput
  }

  export type mensagem_privadaUncheckedUpdateWithoutPessoaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_Messages?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type mensagem_privadaUncheckedUpdateManyWithoutPessoaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mensagem?: StringFieldUpdateOperationsInput | string
    data_cadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    id_Messages?: BigIntFieldUpdateOperationsInput | bigint | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use MessagesCountOutputTypeDefaultArgs instead
     */
    export type MessagesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessagesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GrupoCountOutputTypeDefaultArgs instead
     */
    export type GrupoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GrupoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PessoaCountOutputTypeDefaultArgs instead
     */
    export type PessoaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PessoaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessagesDefaultArgs instead
     */
    export type MessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use grupoDefaultArgs instead
     */
    export type grupoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = grupoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use grupos_pessoasDefaultArgs instead
     */
    export type grupos_pessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = grupos_pessoasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mensagem_grupoDefaultArgs instead
     */
    export type mensagem_grupoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = mensagem_grupoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mensagem_privadaDefaultArgs instead
     */
    export type mensagem_privadaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = mensagem_privadaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pessoaDefaultArgs instead
     */
    export type pessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pessoaDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}